<section
  class="flex flex-col items-center justify-center p-6 border border-[var(--borderEjercicio)] 
  bg-[var(--cardEjercicio)] shadow-[var(--shadowEjercicio)] rounded-xl transition-colors duration-300"
>
  <h3 class="text-lg font-semibold text-[var(--titles)] mb-4 text-center">
    Ejercicio 6 ‚Äì Flujo en un acu√≠fero libre
  </h3>

  <!-- Controles -->
  <div class="flex space-x-3 mb-4">
    <button id="btnWater" class="px-3 py-1 rounded-lg border bg-blue-500 text-white">
      L√≠nea fre√°tica
    </button>
    <button id="btnEquip" class="px-3 py-1 rounded-lg border border-yellow-400 text-yellow-500">
      Equipotencial (70‚Äì80 m)
    </button>
    <button id="btnFlow" class="px-3 py-1 rounded-lg border border-green-500 text-green-500">
      L√≠nea de flujo
    </button>
    <button id="btnClear" class="px-3 py-1 rounded-lg border border-gray-400 text-gray-600 hover:bg-gray-100">
      Limpiar
    </button>
  </div>

  <!-- Canvas -->
  <div class="relative flex flex-col items-center">
    <canvas
      id="acuiferoCanvas"
      width="700"
      height="400"
      class="border border-gray-300 rounded-lg shadow-md cursor-crosshair bg-white"
    ></canvas>

    <p id="loadingText" class="text-gray-500 italic mt-2">Cargando imagen...</p>
    <p id="instructionText" class="text-sm text-gray-600 mt-2">Selecciona 3 puntos para crear una l√≠nea</p>
  </div>

  <p class="mt-5 text-sm text-[var(--textoCardCanvas)] text-center leading-relaxed max-w-md">
    Selecciona 3 puntos para crear la <b>l√≠nea fre√°tica</b>, las <b>l√≠neas equipotenciales (70 m, 75 m, 80 m)</b> 
    y las <b>l√≠neas de flujo</b> sobre el esquema del acu√≠fero libre.
  </p>
</section>

<script is:client>
  // referencias DOM
  const canvas = document.getElementById("acuiferoCanvas");
  const ctx = canvas?.getContext ? canvas.getContext("2d") : null;
  const loadingText = document.getElementById("loadingText");
  const instructionText = document.getElementById("instructionText");

  const btnWater = document.getElementById("btnWater");
  const btnEquip = document.getElementById("btnEquip");
  const btnFlow = document.getElementById("btnFlow");
  const btnClear = document.getElementById("btnClear");

  if (!canvas || !ctx) {
    console.error("Canvas o contexto no disponible.");
  }

  let tool = "waterTable";
  let selectedPoints = [];
  let lines = [];
  let baseImg = new Image();
  let baseLoaded = false;

  // Estrategia mejorada para cargar la imagen
  function loadImageWithFallback() {
    // Intentar cargar desde diferentes fuentes
    const imageSources = [
      // URL directa (puede fallar por CORS pero es m√°s r√°pida)
      "https://books.gw-project.org/conceptual-and-visual-understanding-of-hydraulic-head-and-groundwater-flow/wp-content/uploads/sites/14/2020/12/image33-1.png",
      // Proxy 1
      "https://api.allorigins.win/raw?url=" + encodeURIComponent("https://books.gw-project.org/conceptual-and-visual-understanding-of-hydraulic-head-and-groundwater-flow/wp-content/uploads/sites/14/2020/12/image33-1.png"),
      // Proxy 2 alternativo
      "https://corsproxy.io/?" + encodeURIComponent("https://books.gw-project.org/conceptual-and-visual-understanding-of-hydraulic-head-and-groundwater-flow/wp-content/uploads/sites/14/2020/12/image33-1.png")
    ];

    let currentAttempt = 0;

    function tryNextSource() {
      if (currentAttempt >= imageSources.length) {
        console.error("‚ùå Todas las fuentes de imagen fallaron");
        if (loadingText) {
          loadingText.textContent = "Error: No se pudo cargar la imagen base";
          loadingText.className = "text-red-500 italic mt-2";
        }
        // Crear un canvas con fondo y texto como fallback
        createFallbackCanvas();
        return;
      }

      baseImg = new Image();
      baseImg.crossOrigin = "anonymous";
      
      baseImg.onload = () => {
        console.log("‚úÖ Imagen cargada desde fuente:", currentAttempt);
        baseLoaded = true;
        if (loadingText) loadingText.style.display = "none";
        drawAll();
      };

      baseImg.onerror = () => {
        console.warn(`‚ùå Fuente ${currentAttempt} fall√≥, intentando siguiente...`);
        currentAttempt++;
        tryNextSource();
      };

      console.log(`üîÑ Intentando cargar imagen desde fuente ${currentAttempt}:`, imageSources[currentAttempt]);
      baseImg.src = imageSources[currentAttempt];
    }

    tryNextSource();
  }

  function createFallbackCanvas() {
    if (!ctx) return;
    
    // Fondo del canvas
    ctx.fillStyle = "#f0f8ff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Dibujar un esquema simple de acu√≠fero
    ctx.strokeStyle = "#4682b4";
    ctx.lineWidth = 2;
    
    // L√≠nea base (suelo)
    ctx.beginPath();
    ctx.moveTo(50, 300);
    ctx.lineTo(650, 300);
    ctx.stroke();
    
    // Texto informativo
    ctx.fillStyle = "#666";
    ctx.font = "16px Arial";
    ctx.fillText("Esquema de acu√≠fero libre - Imagen no disponible", 180, 180);
    ctx.font = "14px Arial";
    ctx.fillText("Usa los controles para dibujar l√≠neas fre√°ticas, equipotenciales y de flujo", 120, 210);
    
    baseLoaded = true;
    if (loadingText) loadingText.style.display = "none";
  }

  // Iniciar carga de imagen
  loadImageWithFallback();

  // --- eventos del canvas
  canvas?.addEventListener("click", (e) => {
    if (!baseLoaded) return;
    
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const point = { 
      x: (e.clientX - rect.left) * scaleX, 
      y: (e.clientY - rect.top) * scaleY 
    };
    
    selectedPoints.push(point);
    
    // Si tenemos 3 puntos, creamos la l√≠nea
    if (selectedPoints.length === 3) {
      lines.push({ 
        type: tool, 
        points: [...selectedPoints] 
      });
      selectedPoints = [];
      updateInstruction();
    } else {
      updateInstruction();
    }
    
    drawAll();
  });

  // botones
  btnClear?.addEventListener("click", () => {
    lines = [];
    selectedPoints = [];
    updateInstruction();
    drawAll();
  });

  btnWater?.addEventListener("click", () => {
    setTool("waterTable", btnWater);
    selectedPoints = [];
    updateInstruction();
  });
  
  btnEquip?.addEventListener("click", () => {
    setTool("equipotential", btnEquip);
    selectedPoints = [];
    updateInstruction();
  });
  
  btnFlow?.addEventListener("click", () => {
    setTool("flowLine", btnFlow);
    selectedPoints = [];
    updateInstruction();
  });

  function setTool(newTool, activeButton) {
    tool = newTool;
    [btnWater, btnEquip, btnFlow].forEach((b) => {
      if (!b) return;
      b.classList.remove("bg-blue-500", "bg-yellow-400", "bg-green-500", "text-white");
      b.classList.add("border");
    });
    
    if (activeButton) {
      activeButton.classList.remove("border");
      if (newTool === "waterTable") {
        activeButton.classList.add("bg-blue-500", "text-white");
      } else if (newTool === "equipotential") {
        activeButton.classList.add("bg-yellow-400", "text-white");
      } else if (newTool === "flowLine") {
        activeButton.classList.add("bg-green-500", "text-white");
      }
    }
  }

  function updateInstruction() {
    if (instructionText) {
      if (selectedPoints.length === 0) {
        instructionText.textContent = "Selecciona 3 puntos para crear una l√≠nea";
      } else if (selectedPoints.length === 1) {
        instructionText.textContent = "Selecciona 2 puntos m√°s";
      } else if (selectedPoints.length === 2) {
        instructionText.textContent = "Selecciona 1 punto m√°s para completar la l√≠nea";
      }
    }
  }

  // dibujo
  function drawAll() {
    if (!ctx) return;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Solo dibujar la imagen base si se carg√≥ correctamente
    if (baseLoaded && baseImg.complete && baseImg.naturalWidth !== 0) {
      ctx.drawImage(baseImg, 0, 0, canvas.width, canvas.height);
    }

    // Dibujar las l√≠neas completadas
    for (const l of lines) {
      drawLine(l.points, l.type);
    }

    // Dibujar los puntos seleccionados actualmente
    for (let i = 0; i < selectedPoints.length; i++) {
      drawPoint(selectedPoints[i], i);
    }

    // Si hay puntos seleccionados, dibujar l√≠neas temporales entre ellos
    if (selectedPoints.length > 1) {
      drawTemporaryLine(selectedPoints);
    }
  }

  function drawLine(points, type) {
    if (!ctx || !points || points.length < 2) return;
    
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    
    // Dibujar l√≠nea que conecta los 3 puntos
    for (let i = 1; i < points.length; i++) {
      ctx.lineTo(points[i].x, points[i].y);
    }
    
    ctx.strokeStyle =
      type === "waterTable"
        ? "#1E90FF"
        : type === "equipotential"
        ? "#FFD700"
        : "#00C853";
    ctx.lineWidth = 2.5;
    ctx.stroke();
  }

  function drawTemporaryLine(points) {
    if (!ctx || !points || points.length < 2) return;
    
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    
    // Dibujar l√≠nea temporal entre los puntos seleccionados
    for (let i = 1; i < points.length; i++) {
      ctx.lineTo(points[i].x, points[i].y);
    }
    
    ctx.strokeStyle = "#888888";
    ctx.lineWidth = 1.5;
    ctx.setLineDash([5, 5]); // L√≠nea punteada para las temporales
    ctx.stroke();
    ctx.setLineDash([]); // Restaurar l√≠nea s√≥lida
  }

  function drawPoint(point, index) {
    if (!ctx) return;
    
    ctx.beginPath();
    ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
    ctx.fillStyle = "#FF0000";
    ctx.fill();
    
    // Opcional: mostrar n√∫mero del punto
    ctx.fillStyle = "#000000";
    ctx.font = "12px Arial";
    ctx.fillText(index + 1, point.x + 8, point.y - 8);
  }

  // Inicializar el bot√≥n activo por defecto
  setTool("waterTable", btnWater);
</script>