<section
  class="flex flex-col items-center justify-center p-6 border border-[var(--borderEjercicio)] 
  bg-[var(--cardEjercicio)] shadow-[var(--shadowEjercicio)] rounded-xl transition-colors duration-300"
>
  <h3 class="text-lg font-semibold text-[var(--titles)] mb-4 text-center">
    Ejercicio 6 – Flujo en un acuífero libre
  </h3>

  <div class="flex flex-wrap justify-center gap-3 mb-4">
    <button id="btnWater"
      class="px-4 py-2 rounded-lg font-medium bg-slate-200 text-slate-800 border border-slate-300 
             hover:bg-slate-300 hover:text-slate-900 shadow-sm transition-all duration-200">
      Línea freática
    </button>

    <button id="btnEquip"
      class="px-4 py-2 rounded-lg font-medium bg-gray-100 text-gray-700 border border-gray-300 
             hover:bg-gray-200 hover:text-gray-900 shadow-sm transition-all duration-200">
      Equipotencial (70–80 m)
    </button>

    <button id="btnFlow"
      class="px-4 py-2 rounded-lg font-medium bg-stone-200 text-stone-800 border border-stone-300 
             hover:bg-stone-300 hover:text-stone-900 shadow-sm transition-all duration-200">
      Línea de flujo
    </button>

    <button id="btnClear"
      class="px-4 py-2 rounded-lg font-medium bg-neutral-100 text-neutral-600 border border-neutral-300 
             hover:bg-neutral-200 hover:text-neutral-800 shadow-sm transition-all duration-200">
      Limpiar
    </button>
  </div>

  <div class="relative flex flex-col items-center" style="width:100%;">
    <canvas
      id="acuiferoCanvas"
      class="border border-gray-300 rounded-lg shadow-md cursor-crosshair bg-white"
      style="max-width:700px; width:100%; height:auto; display:block;"
    ></canvas>

    <div id="coordBox"
         style="position:absolute; pointer-events:none; background:rgba(255,255,255,0.9); border:1px solid rgba(0,0,0,0.12);
                padding:6px 8px; border-radius:6px; font-size:12px; color:#111; display:none; transform:translate(8px,8px);">
      x: 0, y: 0 <br/> elev: 0
    </div>

    <p id="loadingText" class="text-gray-500 italic mt-2">Cargando imagen...</p>
    <p id="instructionText" class="text-sm text-gray-600 mt-2">Selecciona 2 puntos para crear la línea freática</p>
  </div>

  <div id="resultsBox" class="hidden mt-4 p-3 rounded-lg bg-slate-50 text-sm text-gray-800 border border-slate-200 max-w-md text-center"></div>

  <p class="mt-5 text-sm text-[var(--textoCardCanvas)] text-center leading-relaxed max-w-md">
    Selecciona 2 puntos para crear la <b>línea freática</b>, las <b>líneas equipotenciales (70 m, 75 m, 80 m)</b> 
    y las <b>líneas de flujo</b> sobre el esquema del acuífero libre.
  </p>
</section>

<script is:client>
/* eslint-disable no-console */
const canvas = document.getElementById("acuiferoCanvas");
const ctx = canvas.getContext("2d");
const loadingText = document.getElementById("loadingText");
const instructionText = document.getElementById("instructionText");
const resultsBox = document.getElementById("resultsBox");
const coordBox = document.getElementById("coordBox");

const btnWater = document.getElementById("btnWater");
const btnEquip = document.getElementById("btnEquip");
const btnFlow = document.getElementById("btnFlow");
const btnClear = document.getElementById("btnClear");

let tool = "waterTable";
let selectedPoints = [];
let lines = [];
let baseImg = new Image();
let baseLoaded = false;
let waterTableCompleted = false;

// pozos (coordenadas internas, mantenidas como antes)
const WELL_A = { x: 20, y: 260, head: 80 };
const WELL_B = { x: 480, y: 280, head: 70 };

// Coordenadas del río en forma de U (con ajuste +100 en X)
const RIVER_POINTS = [
  { x: 323 + 100, y: 163 },
  { x: 336 + 100, y: 184 },
  { x: 360 + 100, y: 199 },
  { x: 385 + 100, y: 182 },
  { x: 397 + 100, y: 162 }
];

// parámetros visuales/limite del río calculado dinámicamente (se ajusta después de cargar la imagen)
let RIVER_X = null;
const RIGHT_MARGIN = 20;

// CARGA IMAGEN con fallbacks (igual que antes)
async function loadImageSafely() {
  const sources = [
    "/src/assets/image33-1.png",
    "https://books.gw-project.org/conceptual-and-visual-understanding-of-hydraulic-head-and-groundwater-flow/wp-content/uploads/sites/14/2020/12/image33-1.png",
    "https://corsproxy.io/?" + encodeURIComponent("https://books.gw-project.org/conceptual-and-visual-understanding-of-hydraulic-head-and-groundwater-flow/wp-content/uploads/sites/14/2020/12/image33-1.png")
  ];

  for (const src of sources) {
    try {
      await new Promise((resolve, reject) => {
        baseImg = new Image();
        baseImg.crossOrigin = "anonymous";
        baseImg.src = src;
        baseImg.onload = () => resolve();
        baseImg.onerror = reject;
      });

      baseLoaded = true;
      loadingText.style.display = "none";

      // ajustar canvas tamaño natural de la imagen
      canvas.width = baseImg.naturalWidth || baseImg.width;
      canvas.height = baseImg.naturalHeight || baseImg.height;

      // detectar posiciones importantes (eje vertical y aproximación río)
      await detectAxisAndDraw();
      return;
    } catch (err) {
      console.warn("Falló cargar:", src, err);
    }
  }

  loadingText.textContent = "Error al cargar la imagen base.";
  // fallback: establecer tamaño razonable
  canvas.width = 700;
  canvas.height = 400;
  detectAxisAndDraw();
}

// Detecta top/bottom del eje vertical y aproxima la posición del río (centro-derecha)
async function detectAxisAndDraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (baseLoaded) ctx.drawImage(baseImg, 0, 0, canvas.width, canvas.height);

  let axisTop = Math.round(canvas.height * 0.11);
  let axisBottom = Math.round(canvas.height * 0.975);
  RIVER_X = RIVER_POINTS[RIVER_POINTS.length - 1].x; // Usar la última coordenada X del río

  canvas.__axisTop = axisTop;
  canvas.__axisBottom = axisBottom;
  canvas.__elevToY = (elev) => {
    const maxE = 100, minE = 0;
    const t = (maxE - elev) / (maxE - minE);
    return axisTop + t * (axisBottom - axisTop);
  };

  drawAll();
}

// Función para generar el patrón de flujo completo
function generateFlowPattern(waterTableLine) {
  if (!waterTableLine || waterTableLine.points.length < 2) return;
  
  const points = waterTableLine.points;
  const p1 = points[0];
  const p2 = points[1];
  
  // GENERAR LÍNEAS EQUIPOTENCIALES (80m, 75m, 70m)
  const equipotentials = [80, 75, 70];
  
  equipotentials.forEach((elev, index) => {
    // Calcular posición Y basada en elevación
    const yPos = canvas.__elevToY ? canvas.__elevToY(elev) : p1.y + (index * (p2.y - p1.y) / 2);
    
    // Crear puntos para la equipotencial curva
    const equipPoints = [];
    const segments = 10;
    
    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      // Curva suave que converge hacia el río
      const x = p1.x + t * (RIVER_X - 50);
      const y = yPos + Math.sin(t * Math.PI) * 30 - 15;
      
      equipPoints.push({ x, y });
    }
    
    lines.push({ 
      type: "equipotential", 
      points: equipPoints,
      elevation: elev 
    });
  });
  
  // GENERAR LÍNEAS DE FLUJO (perpendiculares a las equipotenciales)
  const flowLinesCount = 4;
  
  for (let i = 0; i < flowLinesCount; i++) {
    const t = i / (flowLinesCount - 1);
    const flowPoints = [];
    const segments = 8;
    
    for (let j = 0; j <= segments; j++) {
      const u = j / segments;
      // Línea de flujo curva que sigue el patrón de convergencia
      const x = p1.x + u * (RIVER_X - 20);
      const baseY = p1.y + t * (p2.y - p1.y);
      const y = baseY + Math.sin(u * Math.PI * 0.7) * 40 * (0.5 - Math.abs(t - 0.5));
      
      flowPoints.push({ x, y });
    }
    
    lines.push({ 
      type: "flowLine", 
      points: flowPoints 
    });
  }
}

// convierte coordenadas del evento a coordenadas de imagen (escaladas)
function clientToImageCoords(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  let x = (clientX - rect.left) * scaleX;
  let y = (clientY - rect.top) * scaleY;
  const adjustedX = x >= 100 ? x - 100 : x;
  return { x, y, adjustedX, rect, isValid: x >= 100 };
}

// tooltip coordenadas - mantener visible y funcionando
canvas.addEventListener("mousemove", (e) => {
  if (!baseLoaded) return;
  const { x, y, adjustedX, rect, isValid } = clientToImageCoords(e.clientX, e.clientY);
  if (!isValid) { coordBox.style.display = "none"; return; }

  let elev = null;
  if (canvas.__elevToY) {
    const top = canvas.__axisTop, bottom = canvas.__axisBottom;
    const t = (y - top) / (bottom - top);
    const computedElev = Math.round((1 - t) * 100);
    elev = Math.max(0, Math.min(100, computedElev));
  }

  coordBox.style.display = "block";
  const domLeft = (e.clientX - rect.left);
  const domTop = (e.clientY - rect.top);
  coordBox.style.left = domLeft + "px";
  coordBox.style.top = domTop + "px";
  coordBox.innerHTML = `x: ${Math.round(adjustedX)}, y: ${Math.round(y)}<br/>elev: ${elev !== null ? elev : '-'}`;
});

canvas.addEventListener("mouseout", () => { coordBox.style.display = "none"; });

// CLICK - selección de puntos (ahora 2 puntos para waterTable)
canvas.addEventListener("click", (e) => {
  if (!baseLoaded) return;
  
  if (waterTableCompleted && tool === "waterTable") {
    instructionText.textContent = "Ya has completado la línea freática. Presiona 'Limpiar' para empezar de nuevo.";
    return;
  }

  const { x, y, adjustedX, isValid } = clientToImageCoords(e.clientX, e.clientY);
  if (!isValid) {
    instructionText.textContent = "Selecciona dentro del área válida (x ≥ 100)";
    return;
  }

  const adj = adjustedX;
  const minX = WELL_A.x - 20;
  const maxX = WELL_B.x + 20;
  if (adj < minX || adj > maxX) {
    instructionText.textContent = "Selecciona dentro del rango entre los pozos.";
    return;
  }

  const point = { x, y, adjustedX: adj };
  selectedPoints.push(point);

  if (tool === "waterTable" && selectedPoints.length === 2) {
    const elevation1 = calculateElevation(selectedPoints[0].y);
    const elevation2 = calculateElevation(selectedPoints[1].y);
    
    const [p1, p2] = selectedPoints;
    const slope = (p2.y - p1.y) / (p2.x - p1.x);
    const marginBeforeRiver = 8;
    const extendedX = Math.min(RIVER_X - marginBeforeRiver, canvas.width - RIGHT_MARGIN);
    const targetX = Math.max(p2.x, extendedX);
    const extendedY = p2.y + slope * (targetX - p2.x);

    const extendedPoint = { x: targetX, y: extendedY };
    const waterTableLine = { type: "waterTable", points: [p1, p2, extendedPoint] };
    lines.push(waterTableLine);

    // GENERAR PATRÓN COMPLETO AUTOMÁTICAMENTE
    generateFlowPattern(waterTableLine);
    
    calculateHydraulicData(p1, p2, elevation1, elevation2);

    selectedPoints = [];
    waterTableCompleted = true;
    instructionText.textContent = "Patrón de flujo completado. Presiona 'Limpiar' para empezar de nuevo.";
  } else if (tool !== "waterTable" && selectedPoints.length === 3) {
    lines.push({ type: tool, points: [...selectedPoints] });
    selectedPoints = [];
  }

  updateInstruction();
  drawAll();
});

// Función para calcular elevación basada en posición Y (como entero)
function calculateElevation(y) {
  if (!canvas.__axisTop || !canvas.__axisBottom) return null;
  
  const top = canvas.__axisTop;
  const bottom = canvas.__axisBottom;
  const t = (y - top) / (bottom - top);
  const computedElev = (1 - t) * 100;
  return Math.round(Math.max(0, Math.min(100, computedElev)));
}

// botones
btnClear.addEventListener("click", () => {
  lines = [];
  selectedPoints = [];
  resultsBox.classList.add("hidden");
  waterTableCompleted = false;
  updateInstruction();
  drawAll();
});

btnWater.addEventListener("click", () => {
  if (!waterTableCompleted) {
    setTool("waterTable", btnWater);
  } else {
    instructionText.textContent = "Ya has completado la línea freática. Presiona 'Limpiar' para empezar de nuevo.";
  }
});

btnEquip.addEventListener("click", () => setTool("equipotential", btnEquip));
btnFlow.addEventListener("click", () => setTool("flowLine", btnFlow));

function setTool(newTool, activeButton) {
  tool = newTool;
  [btnWater, btnEquip, btnFlow].forEach((b) => {
    if (!b) return;
    b.classList.remove("bg-slate-400", "bg-gray-300", "bg-stone-300", "text-white");
  });
  if (activeButton) activeButton.classList.add("bg-slate-400", "text-white");
  updateInstruction();
}

function updateInstruction() {
  if (waterTableCompleted && tool === "waterTable") {
    instructionText.textContent = "Patrón de flujo completado. Presiona 'Limpiar' para empezar de nuevo.";
  } else if (tool === "waterTable") {
    instructionText.textContent = `Selecciona ${Math.max(0, 2 - selectedPoints.length)} punto(s) más para la línea freática`;
  } else {
    instructionText.textContent = `Selecciona ${Math.max(0, 3 - selectedPoints.length)} punto(s) más`;
  }
}

/* ---------------- DIBUJO MEJORADO ---------------- */
function drawAll() {
  if (!ctx) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (baseLoaded) ctx.drawImage(baseImg, 0, 0, canvas.width, canvas.height);
  else {
    ctx.fillStyle = "#f8fafc";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  // Dibujar líneas equipotenciales primero (fondo)
  lines.filter(line => line.type === "equipotential").forEach(line => {
    drawEquipotentialLine(line.points, line.elevation);
  });

  // Dibujar líneas de flujo
  lines.filter(line => line.type === "flowLine").forEach(line => {
    drawFlowLine(line.points);
  });

  // Dibujar línea freática (sobre las demás)
  lines.filter(line => line.type === "waterTable").forEach(line => {
    drawWaterTable(line.points);
  });

  // Puntos seleccionados
  for (let i = 0; i < selectedPoints.length; i++) drawPoint(selectedPoints[i], i);
  if (selectedPoints.length > 1) drawTempLine(selectedPoints);
}

// Dibujar línea freática
function drawWaterTable(points) {
  if (!points || points.length < 2) return;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
  ctx.strokeStyle = "#1E40AF";
  ctx.lineWidth = 3;
  ctx.stroke();
}

// Dibujar línea equipotencial con etiqueta
function drawEquipotentialLine(points, elevation) {
  if (!points || points.length < 2) return;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
  ctx.strokeStyle = "#DC2626";
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 3]);
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Etiqueta de elevación
  if (elevation && points.length > 3) {
    const midPoint = points[Math.floor(points.length / 2)];
    ctx.fillStyle = "#DC2626";
    ctx.font = "12px Arial";
    ctx.fillText(`${elevation} m`, midPoint.x + 5, midPoint.y - 5);
  }
}

// Dibujar línea de flujo con flecha
function drawFlowLine(points) {
  if (!points || points.length < 2) return;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
  ctx.strokeStyle = "#059669";
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Dibujar flecha al final
  if (points.length >= 2) {
    const lastPoint = points[points.length - 1];
    const prevPoint = points[points.length - 2];
    drawArrow(prevPoint, lastPoint);
  }
}

// Función para dibujar flecha
function drawArrow(from, to) {
  const headLength = 10;
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const angle = Math.atan2(dy, dx);
  
  ctx.fillStyle = "#059669";
  ctx.beginPath();
  ctx.moveTo(to.x, to.y);
  ctx.lineTo(
    to.x - headLength * Math.cos(angle - Math.PI / 6),
    to.y - headLength * Math.sin(angle - Math.PI / 6)
  );
  ctx.lineTo(
    to.x - headLength * Math.cos(angle + Math.PI / 6),
    to.y - headLength * Math.sin(angle + Math.PI / 6)
  );
  ctx.closePath();
  ctx.fill();
}

function drawPoint(p, i) {
  ctx.beginPath();
  ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
  ctx.fillStyle = "#dc2626";
  ctx.fill();
  ctx.font = "12px Arial";
  ctx.fillStyle = "#000";
  ctx.fillText(i + 1, p.x + 8, p.y - 8);
}

function drawTempLine(points) {
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
  ctx.strokeStyle = "#9ca3af";
  ctx.setLineDash([4, 4]);
  ctx.stroke();
  ctx.setLineDash([]);
}

/* ---------------- CÁLCULOS ---------------- */
function calculateHydraulicData(p1, p2, elev1, elev2) {
  const deltaH = Math.abs(elev1 - elev2);
  const dx_pix = p2.x - p1.x;
  const dy_pix = p1.y - p2.y;
  const dist_pix = Math.sqrt(dx_pix * dx_pix + dy_pix * dy_pix);
  const metersPerPixel = 0.1;
  const L_m = dist_pix * metersPerPixel;
  const i = L_m > 0 ? deltaH / L_m : 0;
  const K = 1e-4;
  const A = 40;
  const Q = K * i * A;

  resultsBox.classList.remove("hidden");
  resultsBox.innerHTML = `
    <b>Resultados (basados en los puntos seleccionados):</b><br/>
    Elevación punto 1: ${elev1} m<br/>
    Elevación punto 2: ${elev2} m<br/>
    Δh (diferencia de elevación): ${deltaH} m<br/>
    Distancia entre puntos: ${dist_pix.toFixed(0)} px ≈ ${L_m.toFixed(1)} m<br/>
    Gradiente hidráulico (i): ${i.toExponential(3)} m/m<br/>
    Conductividad hidráulica (K): ${K.toExponential(2)} m/s<br/>
    Caudal estimado (Q): ${Q.toExponential(3)} m³/s<br/>
    Dirección del flujo: ${elev1 > elev2 ? "del punto 1 → punto 2" : "del punto 2 → punto 1"}
  `;
}

/* ---------------- Inicialización ---------------- */
setTool("waterTable", btnWater);
loadImageSafely();

window.__exercise6 = {
  canvas,
  lines,
  selectedPoints,
  redraw: drawAll,
  detectAxisAndDraw
};
</script>