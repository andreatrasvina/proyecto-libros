<section
  class="flex flex-col items-center justify-center p-6 border border-[var(--borderEjercicio)]
  bg-[var(--cardEjercicio)] shadow-[var(--shadowEjercicio)] rounded-xl transition-colors duration-300"
>
  <h3 class="text-lg font-semibold text-[var(--titles)] mb-4 text-center">
    Ejercicio 6 – Flujo en un acuífero libre
  </h3>

  <div class="flex flex-wrap justify-center gap-3 mb-4">
    <button id="btnEquipotential"
      class="px-4 py-2 rounded-lg font-medium bg-slate-200 text-slate-800 border border-slate-300
             hover:bg-slate-300 hover:text-slate-900 shadow-sm transition-all duration-200">
      Línea Equipotencial
    </button>

    <button id="btnClear"
      class="px-4 py-2 rounded-lg font-medium bg-neutral-100 text-neutral-600 border border-neutral-300
             hover:bg-neutral-200 hover:text-neutral-800 shadow-sm transition-all duration-200">
      Limpiar
    </button>
  </div>

  <div class="relative flex flex-col items-center" style="width:100%; max-width:850px;">
    <canvas
      id="acuiferoCanvas"
      class="border border-gray-300 rounded-lg shadow-md cursor-crosshair bg-white"
      style="width:100%; height:auto; display:block;"
    ></canvas>

    <div id="coordBox"
         style="position:absolute; pointer-events:none; background:rgba(255,255,255,0.95); border:1px solid rgba(0,0,0,0.12);
                padding:6px 8px; border-radius:6px; font-size:12px; color:#111; display:none; transform:translate(8px,8px);">
      x: 0, y: 0 <br/> elev: 0
    </div>

    <p id="loadingText" class="text-gray-500 italic mt-2">Cargando imagen...</p>
    <p id="instructionText" class="text-sm text-gray-600 mt-2">Selecciona 2 puntos para crear la línea equipotencial</p>
  </div>

  <!-- Nuevo: botones de modo -->
  <div class="flex gap-3 mt-3">
    <button id="btnModeManual" class="px-4 py-2 rounded-lg bg-indigo-500 text-white">Modo Manual</button>
    <button id="btnModeCoords" class="px-4 py-2 rounded-lg bg-emerald-500 text-white">Modo Coordenadas</button>
  </div>

  <!-- Nuevo: formulario de ingreso de coordenadas (visible en modo coordenadas) -->
  <div id="coordForm" class="mt-4 p-3 rounded-lg bg-slate-50 text-sm text-gray-800 border border-slate-200 max-w-xl hidden">
    <div style="display:flex; gap:12px; flex-wrap:wrap; align-items:center;">
      <div>
        <div class="font-medium">Punto 1</div>
        <label>X: <input id="in_x1" type="number" step="1" style="width:90px;"></label>
        <label>Y: <input id="in_y1" type="number" step="1" style="width:90px;"></label>
        <label>Z: <input id="in_z1" type="number" step="0.1" style="width:90px;"></label>
      </div>

      <div>
        <div class="font-medium">Punto 2</div>
        <label>X: <input id="in_x2" type="number" step="1" style="width:90px;"></label>
        <label>Y: <input id="in_y2" type="number" step="1" style="width:90px;"></label>
        <label>Z: <input id="in_z2" type="number" step="0.1" style="width:90px;"></label>
      </div>

      <div style="display:flex; flex-direction:column; gap:6px; justify-content:center;">
        <button id="btnApplyCoords" class="px-3 py-2 rounded bg-blue-600 text-white">Usar coordenadas</button>
        <small style="color:#666; max-width:240px;">
          Ingresa X,Y en coordenadas de la imagen (pixeles). Si sólo ingresas Z, Y se calculará desde la elevación usando la escala (0–100 m).
        </small>
      </div>
    </div>
  </div>

  <div id="resultsBox" class="hidden mt-4 p-3 rounded-lg bg-slate-50 text-sm text-gray-800 border border-slate-200 max-w-md text-center"></div>

  <p class="mt-5 text-sm text-[var(--textoCardCanvas)] text-center leading-relaxed max-w-md">
    Selecciona 2 puntos para crear la <b>línea equipotencial</b> sobre el esquema del acuífero libre. También puedes alternar al modo coordenadas.
  </p>
</section>

<script is:client>
/* eslint-disable no-console */
const canvas = document.getElementById("acuiferoCanvas");
const ctx = canvas.getContext("2d");
const loadingText = document.getElementById("loadingText");
const instructionText = document.getElementById("instructionText");
const resultsBox = document.getElementById("resultsBox");
const coordBox = document.getElementById("coordBox");

const btnEquipotential = document.getElementById("btnEquipotential");
const btnClear = document.getElementById("btnClear");

const btnModeManual = document.getElementById("btnModeManual");
const btnModeCoords = document.getElementById("btnModeCoords");
const coordForm = document.getElementById("coordForm");
const btnApplyCoords = document.getElementById("btnApplyCoords");

// inputs
const in_x1 = document.getElementById("in_x1");
const in_y1 = document.getElementById("in_y1");
const in_z1 = document.getElementById("in_z1");
const in_x2 = document.getElementById("in_x2");
const in_y2 = document.getElementById("in_y2");
const in_z2 = document.getElementById("in_z2");

let tool = "equipotential";
let selectedPoints = [];
let lines = [];
let baseImg = new Image();
let baseLoaded = false;
let equipotentialCompleted = false;

// Modos: "manual" o "coords" (por defecto manual)
let modeMode = "manual";

// constantes útiles - AHORA CON EL NUEVO SISTEMA DE COORDENADAS
const ORIGIN_X = 100; // x:100 (real) es el nuevo origen (0 en coordenadas del mouse)
const RIGHT_MARGIN = 20;
let metersPerPixel = 0.1;
let K = 1e-4;
let A = 40;
let generatedPattern = null;

// Definición de pozos como áreas rectangulares según las coordenadas proporcionadas
// Pozo A: (x:94-108, y:26-126)
const WELL_A = { 
  x1: 94, y1: 26,   // esquina superior izquierda
  x2: 108, y2: 126, // esquina inferior derecha
  head: 80 
};

// Pozo B: (x:264-279, y:72-160)
const WELL_B = { 
  x1: 264, y1: 72,   // esquina superior izquierda
  x2: 279, y2: 160,  // esquina inferior derecha
  head: 70 
};

// Coordenadas del río en forma de U (ajustadas al nuevo sistema)
const RIVER_POINTS = [
  { x: 323 + 100 - ORIGIN_X, y: 163 },
  { x: 336 + 100 - ORIGIN_X, y: 184 },
  { x: 360 + 100 - ORIGIN_X, y: 199 },
  { x: 385 + 100 - ORIGIN_X, y: 182 },
  { x: 397 + 100 - ORIGIN_X, y: 162 }
];

let RIVER_X = null;

/* ---------------- CARGA IMAGEN con fallbacks ---------------- */
async function loadImageSafely() {
  const sources = [
    "/src/assets/image33-1.png",
    "https://books.gw-project.org/conceptual-and-visual-understanding-of-hydraulic-head-and-groundwater-flow/wp-content/uploads/sites/14/2020/12/image33-1.png",
    "https://corsproxy.io/?" + encodeURIComponent("https://books.gw-project.org/conceptual-and-visual-understanding-of-hydraulic-head-and-groundwater-flow/wp-content/uploads/sites/14/2020/12/image33-1.png")
  ];

  for (const src of sources) {
    try {
      await new Promise((resolve, reject) => {
        baseImg = new Image();
        baseImg.crossOrigin = "anonymous";
        baseImg.src = src;
        baseImg.onload = () => resolve();
        baseImg.onerror = reject;
      });

      baseLoaded = true;
      loadingText.style.display = "none";

      // ajustar tamaño y compatibilidad con DPR para nitidez
      const dpr = window.devicePixelRatio || 1;
      const cssWidth = baseImg.naturalWidth || baseImg.width || 700;
      const cssHeight = baseImg.naturalHeight || baseImg.height || 400;

      canvas.width = Math.round(cssWidth * dpr);
      canvas.height = Math.round(cssHeight * dpr);
      canvas.style.width = Math.min(800, cssWidth) + "px";
      canvas.style.height = (canvas.height / dpr / cssWidth) * parseFloat(canvas.style.width) + "px"; // mantener aspecto
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      await detectAxisAndDraw();
      return;
    } catch (err) {
      console.warn("Falló cargar:", src, err);
    }
  }

  // si todo falla
  loadingText.textContent = "Error al cargar la imagen base.";
  canvas.width = 700;
  canvas.height = 400;
  ctx.setTransform(1,0,0,1,0,0);
  detectAxisAndDraw();
}

/* ---------------- DETECCIÓN E INICIALIZACIÓN ---------------- */
async function detectAxisAndDraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (baseLoaded) ctx.drawImage(baseImg, 0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));

  let axisTop = Math.round((canvas.height / (window.devicePixelRatio || 1)) * 0.11);
  let axisBottom = Math.round((canvas.height / (window.devicePixelRatio || 1)) * 0.975);
  RIVER_X = (RIVER_POINTS && RIVER_POINTS.length) ? RIVER_POINTS[RIVER_POINTS.length - 1].x : Math.round((canvas.width / (window.devicePixelRatio || 1)) * 0.85);

  // guardamos en canvas para usar en el resto del código
  canvas.__axisTop = axisTop;
  canvas.__axisBottom = axisBottom;
  canvas.__elevToY = (elev) => {
    const maxE = 100, minE = 0;
    const t = (maxE - elev) / (maxE - minE);
    return axisTop + t * (axisBottom - axisTop);
  };

  drawAll();
}

/* ---------------- FUNCIONES DE MODO ---------------- */
function setMode(newMode) {
  modeMode = newMode;
  if (modeMode === "coords") {
    coordForm.classList.remove("hidden");
    btnModeCoords.classList.add("opacity-90");
    btnModeManual.classList.remove("opacity-90");
  } else {
    coordForm.classList.add("hidden");
    btnModeManual.classList.add("opacity-90");
    btnModeCoords.classList.remove("opacity-90");
  }
  // redibujar para que el overlay se muestre/oculte según el modo
  drawAll();
}

/* ---------------- Convierte cliente -> coords de imagen (escalado) - NUEVO SISTEMA ---------------- */
function clientToImageCoords(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  let x = (clientX - rect.left) * (scaleX / (window.devicePixelRatio || 1));
  let y = (clientY - rect.top) * (scaleY / (window.devicePixelRatio || 1));
  
  // NUEVO: Convertir al sistema donde x:100 real = 0 en coordenadas del mouse
  const adjustedX = x - ORIGIN_X;
  return { 
    x, 
    y, 
    adjustedX, 
    realX: x, // Mantener x real para referencia
    rect, 
    // MODIFICADO: Ahora es válido si adjustedX >= 1 (en lugar de 0)
    isValid: adjustedX >= 1
  };
}

/* ---------------- Tooltip de coordenadas - ACTUALIZADO ---------------- */
canvas.addEventListener("mousemove", (e) => {
  if (!baseLoaded) return;
  if (modeMode === "coords") {
    // aún mostramos tooltip para ayudar con ubicación
  }
  const { x, y, adjustedX, realX, rect, isValid } = clientToImageCoords(e.clientX, e.clientY);
  if (!isValid) { 
    coordBox.style.display = "none"; 
    return; 
  }

  let elev = null;
  if (canvas.__elevToY) {
    const top = canvas.__axisTop, bottom = canvas.__axisBottom;
    const t = (y - top) / (bottom - top);
    const computedElev = Math.round((1 - t) * 100);
    elev = Math.max(0, Math.min(100, computedElev));
  }

  coordBox.style.display = "block";
  const domLeft = (e.clientX - rect.left);
  const domTop = (e.clientY - rect.top);
  coordBox.style.left = domLeft + "px";
  coordBox.style.top = domTop + "px";
  
  // NUEVO: Mostrar tanto coordenadas reales como ajustadas
  coordBox.innerHTML = `
    x: ${Math.round(adjustedX)}<br/>
    y: ${Math.round(y)}<br/>
    elev: ${elev !== null ? elev : '-'}
  `;
});

canvas.addEventListener("mouseout", () => { coordBox.style.display = "none"; });

/* ---------------- CLICK: selección de puntos (solo en modo manual) - ACTUALIZADO ---------------- */
canvas.addEventListener("click", (e) => {
  if (!baseLoaded) return;
  if (modeMode !== "manual") {
    instructionText.textContent = "Estás en modo Coordenadas — usa el formulario o vuelve a Modo Manual.";
    return;
  }

  if (equipotentialCompleted && tool === "equipotential") {
    instructionText.textContent = "Ya has completado la línea equipotencial. Presiona 'Limpiar' para empezar de nuevo.";
    return;
  }

  const { x, y, adjustedX, isValid } = clientToImageCoords(e.clientX, e.clientY);
  if (!isValid) {
    // MODIFICADO: Mensaje actualizado para X ≥ 101 real (100 + 1)
    instructionText.textContent = `Selecciona dentro del área válida (x ≥ ${ORIGIN_X + 1} real)`;
    return;
  }

  const adj = adjustedX;
  // MODIFICADO: Rango entre los pozos con las nuevas coordenadas, ahora hasta X:464
  const minX = 1;  // Ahora empieza desde 1
  const maxX = 464;  // Nuevo límite máximo: 464 (en coordenadas ajustadas)
  if (adj < minX || adj > maxX) {
    instructionText.textContent = `Selecciona dentro del rango entre los pozos (x entre ${minX} y ${maxX}).`;
    return;
  }

  const point = { x, y, adjustedX: adj };
  selectedPoints.push(point);

  if (tool === "equipotential" && selectedPoints.length === 2) {
    const elevation1 = calculateElevation(selectedPoints[0].y);
    const elevation2 = calculateElevation(selectedPoints[1].y);

    const [p1, p2] = selectedPoints;
    
    // Calcular punto extendido que se detenga en el río o límites
    let extendedPoint = calculateExtendedPoint(p1, p2);
    
    const equipotentialLine = { type: "equipotential", points: [p1, p2, extendedPoint] };

    // borrar previos patrones y lines de tipo generados para evitar acumulación
    lines = lines.filter(l => l.type === "equipotential"); // conserva solo linea equipotencial previa si la hay
    lines.push(equipotentialLine);

    calculateHydraulicData(p1, p2, elevation1, elevation2);

    selectedPoints = [];
    equipotentialCompleted = true;
    instructionText.textContent = "Línea equipotencial completada. Presiona 'Limpiar' para empezar de nuevo.";
  }

  updateInstruction();
  drawAll();
});

/* ---------------- NUEVA FUNCIÓN: Calcular punto extendido que se detenga en límites ---------------- */
function calculateExtendedPoint(p1, p2) {
  const canvasWidth = canvas.width / (window.devicePixelRatio || 1);
  const riverXReal = RIVER_X + ORIGIN_X; // Convertir a coordenada real
  const maxXReal = 464 + ORIGIN_X; // Nuevo límite máximo en coordenadas reales (564)
  
  // Si es línea vertical
  if (Math.abs(p2.x - p1.x) < 1e-6) {
    const targetX = Math.min(riverXReal, maxXReal, canvasWidth - RIGHT_MARGIN);
    const extendedY = p2.y + (p2.y - p1.y);
    return { x: targetX, y: extendedY };
  }
  
  // Calcular pendiente
  const slope = (p2.y - p1.y) / (p2.x - p1.x);
  
  // Determinar el límite X (el más cercano entre el río, el nuevo límite y el borde derecho)
  const limitX = Math.min(riverXReal, maxXReal, canvasWidth - RIGHT_MARGIN);
  
  // Calcular el punto extendido hasta el límite
  const targetX = Math.max(p2.x, limitX);
  const extendedY = p2.y + slope * (targetX - p2.x);
  
  return { x: targetX, y: extendedY };
}

/* ---------------- UTILIDADES / CÁLCULOS ---------------- */
function calculateElevation(y) {
  if (!canvas.__axisTop || !canvas.__axisBottom) return null;

  const top = canvas.__axisTop;
  const bottom = canvas.__axisBottom;
  const t = (y - top) / (bottom - top);
  const computedElev = (1 - t) * 100;
  return Math.round(Math.max(0, Math.min(100, computedElev)));
}

function calculateHydraulicData(p1, p2, elev1, elev2) {
  const deltaH = Math.abs(elev1 - elev2);
  const dx_pix = p2.x - p1.x;
  const dy_pix = p1.y - p2.y;
  const dist_pix = Math.sqrt(dx_pix * dx_pix + dy_pix * dy_pix);
  
  resultsBox.classList.remove("hidden");
  resultsBox.innerHTML = `
    <b>Resultados (basados en los puntos seleccionados):</b><br/>
    Elevación punto 1: ${elev1} m<br/>
    Elevación punto 2: ${elev2} m<br/>
    Δh (diferencia de elevación): ${deltaH} m<br/>
    Dirección del flujo: ${elev1 > elev2 ? "del punto 1 → punto 2" : "del punto 2 → punto 1"}
  `;
}

/* ---------------- DIBUJO - ACTUALIZADO ---------------- */
function drawAll() {
  if (!ctx) return;
  // Limpiar y dibujar imagen base
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (baseLoaded) {
    ctx.drawImage(baseImg, 0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
  } else {
    ctx.fillStyle = "#f8fafc";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  // Si estamos en modo coordenadas dibujar overlay del plano antes que líneas para visibilidad
  if (modeMode === "coords") {
    drawCartesianOverlay();
  }

  // Dibujar línea equipotencial
  lines.filter(line => line.type === "equipotential").forEach(line => {
    drawEquipotentialLine(line.points);
  });

  // Puntos seleccionados (solo en manual)
  for (let i = 0; i < selectedPoints.length; i++) drawPoint(selectedPoints[i], i);
  if (selectedPoints.length > 1) drawTempLine(selectedPoints);
}

/* ---------------- DIBUJO: Plano cartesiano overlay - ACTUALIZADO ---------------- */
function drawCartesianOverlay() {
  const width = canvas.width / (window.devicePixelRatio || 1);
  const height = canvas.height / (window.devicePixelRatio || 1);

  // Eliminar el fondo semitransparente para mejor visibilidad
  ctx.fillStyle = "rgba(255,255,255,0.0)";
  ctx.fillRect(0, 0, width, height);

  // DIBUJAR EJES X E Y PRINCIPALES - CON NUEVO ORIGEN
  ctx.strokeStyle = "rgba(0,0,0,0.8)";
  ctx.lineWidth = 2;
  
  // Eje Y (vertical) - línea central - AHORA EN x = ORIGIN_X (100 real)
  const yAxisX = ORIGIN_X;
  ctx.beginPath();
  ctx.moveTo(yAxisX, 0);
  ctx.lineTo(yAxisX, height);
  ctx.stroke();
  
  // Eje X (horizontal) - línea central
  const xAxisY = height / 2;
  ctx.beginPath();
  ctx.moveTo(ORIGIN_X, xAxisY); // Comienza en el nuevo origen
  ctx.lineTo(width, xAxisY);
  ctx.stroke();

  // Etiquetas de ejes principales
  ctx.fillStyle = "#000";
  ctx.font = "bold 14px Arial";
  ctx.textAlign = "center";
  
  // Etiqueta del eje X
  ctx.fillText("X", (ORIGIN_X + width) / 2, xAxisY + 25);
  
  // Etiqueta del eje Y
  ctx.save();
  ctx.translate(yAxisX - 25, height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText("Y", 0, 0);
  ctx.restore();

  // Dibujar marcas en los ejes con valores REALES
  ctx.strokeStyle = "rgba(0,0,0,0.15)";
  ctx.lineWidth = 1;
  ctx.font = "12px Arial";
  ctx.fillStyle = "#111";
  ctx.textAlign = "center";

  // Marcas en el eje X (cada 50 píxeles) - MOSTRANDO COORDENADAS REALES
  for (let x = ORIGIN_X; x < width; x += 50) {
    // Solo dibujar marcas dentro del área visible
    ctx.beginPath();
    ctx.moveTo(x, xAxisY - 5);
    ctx.lineTo(x, xAxisY + 5);
    ctx.stroke();
    
    // MOSTRAR COORDENADA X REAL (no ajustada)
    ctx.fillText(x.toString(), x, xAxisY + 20);
  }

  // Marcas en el eje Y (cada 50 píxeles)
  for (let y = 50; y < height; y += 50) {
    if (y !== xAxisY) {
      ctx.beginPath();
      ctx.moveTo(yAxisX - 5, y);
      ctx.lineTo(yAxisX + 5, y);
      ctx.stroke();
      
      // Etiquetas del eje Y (coordenadas reales)
      ctx.fillText(y.toString(), yAxisX - 20, y + 4);
    }
  }

  // Etiqueta del origen (ORIGIN_X, 0) - NUEVO ORIGEN
  ctx.fillText(ORIGIN_X.toString(), yAxisX - 10, xAxisY + 15);

  // Dibujar una grilla sutil - USANDO COORDENADAS REALES
  ctx.strokeStyle = "rgba(0,0,0,0.06)";
  for (let x = ORIGIN_X; x <= width; x += 50) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, height);
    ctx.stroke();
  }
  for (let y = 0; y <= height; y += 50) {
    ctx.beginPath();
    ctx.moveTo(ORIGIN_X, y);
    ctx.lineTo(width, y);
    ctx.stroke();
  }
}

/* ---------- Dibujo de elementos (sin cambios) ---------- */
function drawEquipotentialLine(points) {
  if (!points || points.length < 2) return;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
  ctx.strokeStyle = "#1E40AF";
  ctx.lineWidth = 3;
  ctx.stroke();
}

function drawPoint(p, i) {
  ctx.beginPath();
  ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
  ctx.fillStyle = "#dc2626";
  ctx.fill();
  ctx.font = "12px Arial";
  ctx.fillStyle = "#000";
  ctx.fillText(i + 1, p.x + 8, p.y - 8);
}

function drawTempLine(points) {
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
  ctx.strokeStyle = "#9ca3af";
  ctx.setLineDash([4, 4]);
  ctx.stroke();
  ctx.setLineDash([]);
}

/* ---------------- Botón Limpiar ---------------- */
btnClear.addEventListener("click", () => {
  lines = [];
  selectedPoints = [];
  resultsBox.classList.add("hidden");
  equipotentialCompleted = false;
  generatedPattern = null;
  updateInstruction();
  drawAll();
});

/* ---------------- Botones de herramienta ---------------- */
btnEquipotential.addEventListener("click", () => {
  if (!equipotentialCompleted) {
    setTool("equipotential", btnEquipotential);
  } else {
    instructionText.textContent = "Ya has completado la línea equipotencial. Presiona 'Limpiar' para empezar de nuevo.";
  }
});

function setTool(newTool, activeButton) {
  tool = newTool;
  btnEquipotential.classList.remove("bg-slate-400", "text-white");
  if (activeButton) activeButton.classList.add("bg-slate-400", "text-white");
  updateInstruction();
}

function updateInstruction() {
  if (equipotentialCompleted && tool === "equipotential") {
    instructionText.textContent = "Línea equipotencial completada. Presiona 'Limpiar' para empezar de nuevo.";
  } else if (tool === "equipotential") {
    instructionText.textContent = `Selecciona ${Math.max(0, 2 - selectedPoints.length)} punto(s) más para la línea equipotencial`;
  }
}

/* ---------------- Modo botones ---------------- */
btnModeManual.addEventListener("click", () => setMode("manual"));
btnModeCoords.addEventListener("click", () => setMode("coords"));

/* ---------------- Aplicar coordenadas desde el formulario - ACTUALIZADO ---------------- */
btnApplyCoords.addEventListener("click", () => {
  // leer inputs - AHORA EL USUARIO INGRESA COORDENADAS REALES
  const x1 = in_x1.value ? Number(in_x1.value) : null;
  const y1 = in_y1.value ? Number(in_y1.value) : null;
  const z1 = in_z1.value ? Number(in_z1.value) : null;
  const x2 = in_x2.value ? Number(in_x2.value) : null;
  const y2 = in_y2.value ? Number(in_y2.value) : null;
  const z2 = in_z2.value ? Number(in_z2.value) : null;

  if ((x1 === null || x2 === null) && (z1 === null || z2 === null)) {
    alert("Por favor ingresa al menos las coordenadas X para ambos puntos o las elevaciones Z.");
    return;
  }

  // si el usuario proporcionó Z pero no Y, calculamos Y desde elevación
  let p1y = y1;
  if ((p1y === null || isNaN(p1y)) && z1 !== null && canvas.__elevToY) p1y = canvas.__elevToY(z1);

  let p2y = y2;
  if ((p2y === null || isNaN(p2y)) && z2 !== null && canvas.__elevToY) p2y = canvas.__elevToY(z2);

  if ((p1y === null || p2y === null) || (x1 === null || x2 === null)) {
    alert("Necesitamos valores X y Y (o X + Z para calcular Y).");
    return;
  }

  // NUEVO: Convertir coordenadas reales a ajustadas
  const adjustedX1 = x1 - ORIGIN_X;
  const adjustedX2 = x2 - ORIGIN_X;

  // construir puntos (usando coordenadas reales para dibujo, ajustadas para validación)
  const p1 = { x: x1, y: p1y, adjustedX: adjustedX1 };
  const p2 = { x: x2, y: p2y, adjustedX: adjustedX2 };

  // MODIFICADO: Validación con las nuevas coordenadas, ahora hasta X:464
  const minX = 1;  // Ahora empieza desde 1
  const maxX = 464;  // Nuevo límite máximo: 464 (en coordenadas ajustadas)
  if (adjustedX1 < minX || adjustedX1 > maxX || adjustedX2 < minX || adjustedX2 > maxX) {
    alert(`Las coordenadas X ajustadas deben estar entre ${minX} y ${maxX}`);
    return;
  }

  // elevaciones finales (usar z si el usuario lo proporcionó, si no usar calculateElevation)
  const elev1 = (z1 !== null && !isNaN(z1)) ? Math.round(z1) : calculateElevation(p1.y);
  const elev2 = (z2 !== null && !isNaN(z2)) ? Math.round(z2) : calculateElevation(p2.y);

  // Usar la misma función calculateExtendedPoint para consistencia
  let extendedPoint = calculateExtendedPoint(p1, p2);

  const equipotentialLine = { type: "equipotential", points: [p1, p2, extendedPoint] };

  // eliminar previos de tipo equipotential para evitar acumulación
  lines = lines.filter(l => l.type === "equipotential");
  lines.push(equipotentialLine);

  calculateHydraulicData(p1, p2, elev1, elev2);

  // marcar completado, ocultar formulario y actualizar UI
  equipotentialCompleted = true;
  coordForm.classList.add("hidden");
  instructionText.textContent = "Línea equipotencial completada (modo Coordenadas). Presiona 'Limpiar' para empezar de nuevo.";
  drawAll();
});

/* ---------------- Inicialización ---------------- */
setTool("equipotential", btnEquipotential);
setMode("manual");
loadImageSafely();

window.__exercise6 = {
  canvas,
  lines,
  selectedPoints,
  redraw: drawAll,
  detectAxisAndDraw
};
</script>