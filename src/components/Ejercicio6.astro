---
// Ejercicio6ASTRO.astro
// Componente Astro para el Ejercicio 6 - Flujo en un Acuífero Libre
---
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Ejercicio 6 - Flujo en un acuífero libre</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --borderEjercicio: #e2e8f0;
            --cardEjercicio: #ffffff;
            --shadowEjercicio: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --titles: #1e293b;
            --textoCardCanvas: #475569;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4">
    <section
        class="flex flex-col items-center justify-center p-6 border border-[var(--borderEjercicio)]
        bg-[var(--cardEjercicio)] shadow-[var(--shadowEjercicio)] rounded-xl transition-colors duration-300"
        >
        <h3 class="text-lg font-semibold text-[var(--titles)] mb-4 text-center">
            Ejercicio 6 – Flujo en un acuífero libre
        </h3>

        <div class="flex flex-wrap justify-center gap-3 mb-4">
            <button id="btnEquipotential"
                class="px-4 py-2 rounded-lg font-medium bg-slate-200 text-slate-800 border border-slate-300
                    hover:bg-slate-300 hover:text-slate-900 shadow-sm transition-all duration-200">
                Línea Equipotencial
            </button>

            <button id="btnAdditionalPoints"
                class="px-4 py-2 rounded-lg font-medium bg-purple-200 text-purple-800 border border-purple-300
                    hover:bg-purple-300 hover:text-purple-900 shadow-sm transition-all duration-200">
                Puntos Adicionales
            </button>

            <button id="btnGenerateContours"
                class="px-4 py-2 rounded-lg font-medium bg-emerald-400 text-white border border-emerald-500
                    hover:bg-emerald-500 shadow-sm transition-all duration-200">
                Generar equipotenciales
            </button>

            <button id="btnClear"
                class="px-4 py-2 rounded-lg font-medium bg-neutral-100 text-neutral-600 border border-neutral-300
                    hover:bg-neutral-200 hover:text-neutral-800 shadow-sm transition-all duration-200">
                Limpiar
            </button>
        </div>

        <div class="relative flex flex-col items-center" style="width:100%; max-width:850px;">
            <canvas
                id="acuiferoCanvas"
                class="border border-gray-300 rounded-lg shadow-md cursor-crosshair bg-white"
                style="width:100%; height:auto; display:block;"
            ></canvas>

            <div id="coordBox"
                style="position:absolute; pointer-events:none; background:rgba(255,255,255,0.95); border:1px solid rgba(0,0,0,0.12);
                    padding:6px 8px; border-radius:6px; font-size:12px; color:#111; display:none; transform:translate(8px,8px);">
                x: 0, y: 0 <br/> elev: 0
            </div>

            <p id="loadingText" class="text-gray-500 italic mt-2">Cargando imagen...</p>
            <p id="instructionText" class="text-sm text-gray-600 mt-2">Selecciona 2 puntos para crear la línea equipotencial</p>
        </div>

        <!-- Modos -->
        <div class="flex gap-3 mt-3">
            <button id="btnModeManual" class="px-4 py-2 rounded-lg bg-indigo-500 text-white">Modo Manual</button>
            <button id="btnModeCoords" class="px-4 py-2 rounded-lg bg-emerald-500 text-white">Modo Coordenadas</button>
        </div>

        <!-- Formulario de coordenadas -->
        <div id="coordForm" class="mt-4 p-3 rounded-lg bg-slate-50 text-sm text-gray-800 border border-slate-200 max-w-xl hidden">
            <div class="mb-4">
                <label class="font-medium">Tipo de elemento:</label>
                <select id="coordElementType" class="ml-2 p-1 border rounded">
                    <option value="equipotential">Línea Equipotencial</option>
                    <option value="additional">Puntos Adicionales</option>
                </select>
            </div>

            <div style="display:flex; gap:12px; flex-wrap:wrap; align-items:center;">
                <div>
                    <div class="font-medium">Punto 1</div>
                    <label>X: <input id="in_x1" type="number" step="1" style="width:90px;"></label>
                    <label>Y: <input id="in_y1" type="number" step="1" style="width:90px;"></label>
                    <label>Z: <input id="in_z1" type="number" step="0.1" style="width:90px;"></label>
                </div>

                <div>
                    <div class="font-medium">Punto 2</div>
                    <label>X: <input id="in_x2" type="number" step="1" style="width:90px;"></label>
                    <label>Y: <input id="in_y2" type="number" step="1" style="width:90px;"></label>
                    <label>Z: <input id="in_z2" type="number" step="0.1" style="width:90px;"></label>
                </div>

                <div style="display:flex; flex-direction:column; gap:6px; justify-content:center;">
                    <button id="btnApplyCoords" class="px-3 py-2 rounded bg-blue-600 text-white">Usar coordenadas</button>
                    <small style="color:#666; max-width:240px;">
                        Ingresa X,Y en coordenadas de la imagen (pixeles). Si sólo ingresas Z, Y se calculará desde la elevación usando la escala (0–100 m).
                    </small>
                </div>
            </div>
        </div>

        <div id="resultsBox" class="hidden mt-4 p-3 rounded-lg bg-slate-50 text-sm text-gray-800 border border-slate-200 max-w-md text-left"></div>

        <p class="mt-5 text-sm text-[var(--textoCardCanvas)] text-center leading-relaxed max-w-md">
            Selecciona 2 puntos para crear la <b>línea equipotencial</b> sobre el esquema del acuífero libre. También puedes alternar al modo coordenadas.
        </p>
    </section>

    <script is:inline>
        /* eslint-disable no-console */
        const canvas = document.getElementById("acuiferoCanvas");
        const ctx = canvas.getContext("2d");
        const loadingText = document.getElementById("loadingText");
        const instructionText = document.getElementById("instructionText");
        const resultsBox = document.getElementById("resultsBox");
        const coordBox = document.getElementById("coordBox");

        const btnEquipotential = document.getElementById("btnEquipotential");
        const btnAdditionalPoints = document.getElementById("btnAdditionalPoints");
        const btnGenerateContours = document.getElementById("btnGenerateContours");
        const btnClear = document.getElementById("btnClear");

        const btnModeManual = document.getElementById("btnModeManual");
        const btnModeCoords = document.getElementById("btnModeCoords");
        const coordForm = document.getElementById("coordForm");
        const btnApplyCoords = document.getElementById("btnApplyCoords");
        const coordElementType = document.getElementById("coordElementType");

        // inputs
        const in_x1 = document.getElementById("in_x1");
        const in_y1 = document.getElementById("in_y1");
        const in_z1 = document.getElementById("in_z1");
        const in_x2 = document.getElementById("in_x2");
        const in_y2 = document.getElementById("in_y2");
        const in_z2 = document.getElementById("in_z2");

        let tool = "equipotential";
        let selectedPoints = [];
        let additionalPoints = [];
        let lines = [];
        let baseImg = new Image();
        let baseLoaded = false;
        let equipotentialCompleted = false;
        let additionalPointsCompleted = false;

        // Modos: "manual" o "coords" (por defecto manual)
        let modeMode = "manual";

        // constantes útiles
        const ORIGIN_X = 100; // x:100 (real) es el nuevo origen (0 en coordenadas del mouse)
        const RIGHT_MARGIN = 20;
        let metersPerPixel = 0.1;   // escala: metros por pixel (ajusta si necesitas)
        let K = 1e-4;
        let A = 40;

        // Wells (control points)
        const WELL_A = {
            x1: 94, y1: 26,   // esquina superior izquierda (valores en imagen real)
            x2: 108, y2: 126,
            head: 80
        };
        const WELL_B = {
            x1: 264, y1: 72,
            x2: 279, y2: 160,
            head: 70
        };

        // River sample head (approx) - opcional; si no quieres usarlo, déjalo null
        const RIVER_HEAD = null; // si lo pones, por ejemplo 65, ayudará a anclar contornos al río

        // coordenadas de muestra del río (para visual)
        const RIVER_POINTS = [
            { x: 323 + 100 - ORIGIN_X, y: 163 },
            { x: 336 + 100 - ORIGIN_X, y: 184 },
            { x: 360 + 100 - ORIGIN_X, y: 199 },
            { x: 385 + 100 - ORIGIN_X, y: 182 },
            { x: 397 + 100 - ORIGIN_X, y: 162 }
        ];

        let RIVER_X = null;

        // parámetros de la rejilla para IDW + marching squares
        const GRID_STEP = 12; // píxeles (coarser = más rápido, finer = más preciso)
        const IDW_POWER = 2;
        const EPS = 1e-6;

        // niveles a dibujar (equipotenciales)
        const CONTOUR_LEVELS = [80, 75, 70];

        /* ---------------- CARGA IMAGEN con fallbacks ---------------- */
        async function loadImageSafely() {
            const sources = [
                "/src/assets/image33-1.png",
                "https://books.gw-project.org/conceptual-and-visual-understanding-of-hydraulic-head-and-groundwater-flow/wp-content/uploads/sites/14/2020/12/image33-1.png",
                "https://corsproxy.io/?" + encodeURIComponent("https://books.gw-project.org/conceptual-and-visual-understanding-of-hydraulic-head-and-groundwater-flow/wp-content/uploads/sites/14/2020/12/image33-1.png")
            ];

            for (const src of sources) {
                try {
                    await new Promise((resolve, reject) => {
                        baseImg = new Image();
                        baseImg.crossOrigin = "anonymous";
                        baseImg.src = src;
                        baseImg.onload = () => resolve();
                        baseImg.onerror = reject;
                    });

                    baseLoaded = true;
                    loadingText.style.display = "none";

                    const dpr = window.devicePixelRatio || 1;
                    const cssWidth = baseImg.naturalWidth || baseImg.width || 700;
                    const cssHeight = baseImg.naturalHeight || baseImg.height || 400;

                    canvas.width = Math.round(cssWidth * dpr);
                    canvas.height = Math.round(cssHeight * dpr);
                    canvas.style.width = Math.min(800, cssWidth) + "px";
                    canvas.style.height = (canvas.height / dpr / cssWidth) * parseFloat(canvas.style.width) + "px";
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                    await detectAxisAndDraw();
                    return;
                } catch (err) {
                    console.warn("Falló cargar:", src, err);
                }
            }

            // si todo falla
            loadingText.textContent = "Error al cargar la imagen base.";
            canvas.width = 700;
            canvas.height = 400;
            ctx.setTransform(1,0,0,1,0,0);
            detectAxisAndDraw();
        }

        /* ---------------- DETECCIÓN E INICIALIZACIÓN ---------------- */
        async function detectAxisAndDraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (baseLoaded) ctx.drawImage(baseImg, 0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));

            let axisTop = Math.round((canvas.height / (window.devicePixelRatio || 1)) * 0.11);
            let axisBottom = Math.round((canvas.height / (window.devicePixelRatio || 1)) * 0.975);
            RIVER_X = (RIVER_POINTS && RIVER_POINTS.length) ? RIVER_POINTS[RIVER_POINTS.length - 1].x : Math.round((canvas.width / (window.devicePixelRatio || 1)) * 0.85);

            canvas.__axisTop = axisTop;
            canvas.__axisBottom = axisBottom;
            canvas.__elevToY = (elev) => {
                const maxE = 100, minE = 0;
                const t = (maxE - elev) / (maxE - minE);
                return axisTop + t * (axisBottom - axisTop);
            };

            drawAll();
        }

        /* ---------------- FUNCIONES DE MODO ---------------- */
        function setMode(newMode) {
            modeMode = newMode;
            if (modeMode === "coords") {
                coordForm.classList.remove("hidden");
                btnModeCoords.classList.add("opacity-90");
                btnModeManual.classList.remove("opacity-90");
                coordElementType.value = tool === "additionalPoints" ? "additional" : "equipotential";
            } else {
                coordForm.classList.add("hidden");
                btnModeManual.classList.add("opacity-90");
                btnModeCoords.classList.remove("opacity-90");
            }
            drawAll();
        }

        /* ---------------- Convierte cliente -> coords de imagen ---------------- */
        function clientToImageCoords(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (clientX - rect.left) * (scaleX / (window.devicePixelRatio || 1));
            let y = (clientY - rect.top) * (scaleY / (window.devicePixelRatio || 1));
            const adjustedX = x - ORIGIN_X;
            return {
                x,
                y,
                adjustedX,
                realX: x,
                rect,
                isValid: adjustedX >= 1
            };
        }

        /* ---------------- Tooltip ---------------- */
        canvas.addEventListener("mousemove", (e) => {
            if (!baseLoaded) return;
            const { x, y, adjustedX, realX, rect, isValid } = clientToImageCoords(e.clientX, e.clientY);
            if (!isValid) {
                coordBox.style.display = "none";
                return;
            }

            let elev = null;
            if (canvas.__elevToY) {
                const top = canvas.__axisTop, bottom = canvas.__axisBottom;
                const t = (y - top) / (bottom - top);
                const computedElev = Math.round((1 - t) * 100);
                elev = Math.max(0, Math.min(100, computedElev));
            }

            coordBox.style.display = "block";
            const domLeft = (e.clientX - rect.left);
            const domTop = (e.clientY - rect.top);
            coordBox.style.left = domLeft + "px";
            coordBox.style.top = domTop + "px";

            coordBox.innerHTML = `
                x: ${Math.round(adjustedX)}<br/>
                y: ${Math.round(y)}<br/>
                elev: ${elev !== null ? elev : '-'}
            `;
        });

        canvas.addEventListener("mouseout", () => { coordBox.style.display = "none"; });

        /* ---------------- CLICK: selección de puntos (manual) ---------------- */
        canvas.addEventListener("click", (e) => {
            if (!baseLoaded) return;
            if (modeMode !== "manual") {
                instructionText.textContent = "Estás en modo Coordenadas — usa el formulario o vuelve a Modo Manual.";
                return;
            }

            if (additionalPointsCompleted && tool === "additionalPoints") {
                instructionText.textContent = "Ya has completado la selección de puntos adicionales. Presiona 'Limpiar' para empezar de nuevo.";
                return;
            }
            if (equipotentialCompleted && tool === "equipotential") {
                instructionText.textContent = "Ya has completado la línea equipotencial. Cambia a 'Puntos Adicionales' o presiona 'Limpiar' para empezar de nuevo.";
                return;
            }

            const { x, y, adjustedX, isValid } = clientToImageCoords(e.clientX, e.clientY);
            if (!isValid) {
                instructionText.textContent = `Selecciona dentro del área válida (x ≥ ${ORIGIN_X + 1} real)`;
                return;
            }

            const adj = adjustedX;
            const minX = 1;
            const maxX = 464;
            if (adj < minX || adj > maxX) {
                instructionText.textContent = `Selecciona dentro del rango entre los pozos (x entre ${minX} y ${maxX}).`;
                return;
            }

            const point = { x, y, adjustedX: adj, elevation: calculateElevation(y) };

            if (tool === "equipotential") {
                selectedPoints.push(point);

                if (selectedPoints.length === 2) {
                    const elevation1 = selectedPoints[0].elevation;
                    const elevation2 = selectedPoints[1].elevation;
                    const [p1, p2] = selectedPoints;

                    let extendedPoint = calculateExtendedPoint(p1, p2);

                    const equipotentialLine = { type: "equipotential", points: [p1, p2, extendedPoint] };

                    const midPoint = {
                        x: (p1.x + p2.x) / 2,
                        y: (p1.y + p2.y) / 2
                    };
                    const avgElevation = (elevation1 + elevation2) / 2;

                    equipotentialLine.midPoint = midPoint;
                    equipotentialLine.avgElevation = avgElevation;

                    lines = lines.filter(l => l.type === "equipotential");
                    lines.push(equipotentialLine);

                    calculateHydraulicData(p1, p2, elevation1, elevation2, midPoint, avgElevation);

                    selectedPoints = [];
                    equipotentialCompleted = true;
                    instructionText.textContent = "Línea equipotencial completada. Ahora puedes seleccionar 'Puntos Adicionales' o generar contornos.";
                }
            } else if (tool === "additionalPoints") {
                if (!equipotentialCompleted) {
                    instructionText.textContent = "Primero completa la línea equipotencial antes de agregar puntos adicionales.";
                    return;
                }

                additionalPoints.push(point);

                if (additionalPoints.length === 2) {
                    const additionalLine = {
                        type: "additional",
                        points: [additionalPoints[0], additionalPoints[1]]
                    };

                    const midPoint = {
                        x: (additionalPoints[0].x + additionalPoints[1].x) / 2,
                        y: (additionalPoints[0].y + additionalPoints[1].y) / 2
                    };
                    const avgElevation = (additionalPoints[0].elevation + additionalPoints[1].elevation) / 2;

                    additionalLine.midPoint = midPoint;
                    additionalLine.avgElevation = avgElevation;

                    lines.push(additionalLine);

                    additionalPointsCompleted = true;
                    instructionText.textContent = "Puntos adicionales completados. Presiona 'Limpiar' para empezar de nuevo.";
                    showAdditionalPointsInfo();
                }
            }

            updateInstruction();
            drawAll();
        });

        /* ---------------- Mostrar información de puntos adicionales ---------------- */
        function showAdditionalPointsInfo() {
            if (additionalPoints.length < 2) return;
            const p1 = additionalPoints[0];
            const p2 = additionalPoints[1];
            const elev1 = p1.elevation;
            const elev2 = p2.elevation;
            const additionalLine = lines.find(line => line.type === "additional");

            const infoDiv = document.createElement("div");
            infoDiv.className = "mt-3 p-3 rounded-lg bg-purple-50 text-sm text-purple-800 border border-purple-200";

            let infoHTML = `
                <b>Puntos Adicionales:</b><br/>
                Punto A: Elevación ${elev1} m (x:${Math.round(p1.adjustedX)}, y:${Math.round(p1.y)})<br/>
                Punto B: Elevación ${elev2} m (x:${Math.round(p2.adjustedX)}, y:${Math.round(p2.y)})<br/>
                Diferencia de elevación: ${Math.abs(elev1 - elev2).toFixed(1)} m
            `;

            if (additionalLine && additionalLine.midPoint) {
                infoHTML += `<br/>Punto Medio: Elevación ${additionalLine.avgElevation.toFixed(1)} m (x:${Math.round(additionalLine.midPoint.x - ORIGIN_X)}, y:${Math.round(additionalLine.midPoint.y)})`;
            }

            infoDiv.innerHTML = infoHTML;

            resultsBox.appendChild(infoDiv);
        }

        /* ---------------- Calcular punto extendido ---------------- */
        function calculateExtendedPoint(p1, p2) {
            const canvasWidth = canvas.width / (window.devicePixelRatio || 1);
            const riverXReal = RIVER_X + ORIGIN_X;
            const maxXReal = 464 + ORIGIN_X;

            if (Math.abs(p2.x - p1.x) < 1e-6) {
                const targetX = Math.min(riverXReal, maxXReal, canvasWidth - RIGHT_MARGIN);
                const extendedY = p2.y + (p2.y - p1.y);
                return { x: targetX, y: extendedY };
            }

            const slope = (p2.y - p1.y) / (p2.x - p1.x);
            const limitX = Math.min(riverXReal, maxXReal, canvasWidth - RIGHT_MARGIN);
            const targetX = Math.max(p2.x, limitX);
            const extendedY = p2.y + slope * (targetX - p2.x);

            return { x: targetX, y: extendedY };
        }

        /* ---------------- UTILIDADES / CÁLCULOS ---------------- */
        function calculateElevation(y) {
            if (!canvas.__axisTop || !canvas.__axisBottom) return null;
            const top = canvas.__axisTop;
            const bottom = canvas.__axisBottom;
            const t = (y - top) / (bottom - top);
            const computedElev = (1 - t) * 100;
            return Math.round(Math.max(0, Math.min(100, computedElev)));
        }

        function calculateHydraulicData(p1, p2, elev1, elev2, midPoint, avgElevation) {
            const deltaH = Math.abs(elev1 - elev2);
            const dx_pix = p2.x - p1.x;
            const dy_pix = p1.y - p2.y;
            const dist_pix = Math.sqrt(dx_pix * dx_pix + dy_pix * dy_pix);
            const dist_m = dist_pix * metersPerPixel;
            const i = (deltaH / (dist_m || EPS));

            resultsBox.classList.remove("hidden");
            resultsBox.innerHTML = `
                <b>Resultados (basados en los puntos seleccionados):</b><br/>
                Elevación punto 1: ${elev1} m<br/>
                Elevación punto 2: ${elev2} m<br/>
                Δh (diferencia de elevación): ${deltaH} m<br/>
                Distancia (m): ${dist_m.toFixed(2)} m<br/>
                Gradiente i = Δh/ΔL: ${i.toFixed(4)} (m/m)<br/>
                Fórmula de Darcy: Q = -K * i * A (con K=${K}, A=${A} m²)<br/>
                Elevación promedio: ${avgElevation.toFixed(1)} m<br/>
                Dirección del flujo: ${elev1 > elev2 ? "del punto 1 → punto 2" : "del punto 2 → punto 1"}
            `;
        }

        /* ---------------- DIBUJO - incluidas nuevas funciones de contornos y flujo ---------------- */
        function drawAll() {
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (baseLoaded) {
                ctx.drawImage(baseImg, 0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
            } else {
                ctx.fillStyle = "#f8fafc";
                ctx.fillRect(0,0,canvas.width,canvas.height);
            }

            if (modeMode === "coords") {
                drawCartesianOverlay();
            }

            // Dibujar líneas guardadas
            lines.filter(line => line.type === "equipotential").forEach(line => {
                drawEquipotentialLine(line.points);
                if (line.midPoint) drawMidPoint(line.midPoint, line.avgElevation);
            });

            lines.filter(line => line.type === "additional").forEach(line => {
                drawAdditionalLine(line.points);
                if (line.midPoint) drawAdditionalMidPoint(line.midPoint, line.avgElevation);
            });

            // puntos adicionales y seleccionados
            additionalPoints.forEach((point, index) => drawAdditionalPoint(point, index));
            for (let i = 0; i < selectedPoints.length; i++) drawPoint(selectedPoints[i], i);
            if (selectedPoints.length > 1) drawTempLine(selectedPoints);

            // Dibujar pozos (visual)
            drawWells();

            // Si hay contornos generados, dibujarlos (guardados en canvas.__contours)
            if (canvas.__contours) {
                drawContoursOnCanvas(canvas.__contours);
            }

            // Leyenda si existen contornos
            if (canvas.__contours && canvas.__contours.length) {
                drawLegend();
            }
        }

        function drawWells() {
            // Pozo A center aproximado
            const cxA = (WELL_A.x1 + WELL_A.x2) / 2;
            const cyA = (WELL_A.y1 + WELL_A.y2) / 2;
            ctx.beginPath();
            ctx.rect(cxA-8, cyA-60, 16, 60);
            ctx.fillStyle = "#0ea5e9"; ctx.fill(); ctx.strokeStyle = "#034f84"; ctx.stroke();
            // etiqueta
            ctx.font = "12px Arial"; ctx.fillStyle = "#000"; ctx.fillText(`${WELL_A.head} m`, cxA, cyA-70);

            const cxB = (WELL_B.x1 + WELL_B.x2) / 2;
            const cyB = (WELL_B.y1 + WELL_B.y2) / 2;
            ctx.beginPath();
            ctx.rect(cxB-8, cyB-60, 16, 60);
            ctx.fillStyle = "#0ea5e9"; ctx.fill(); ctx.strokeStyle = "#034f84"; ctx.stroke();
            ctx.font = "12px Arial"; ctx.fillStyle = "#000"; ctx.fillText(`${WELL_B.head} m`, cxB, cyB-70);
        }

        function drawEquipotentialLine(points) {
            if (!points || points.length < 2) return;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
            ctx.strokeStyle = "#1E40AF";
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function drawPoint(p, i) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = "#dc2626";
            ctx.fill();
            ctx.font = "12px Arial";
            ctx.fillStyle = "#000";
            ctx.fillText(i + 1, p.x + 8, p.y - 8);
        }

        function drawTempLine(points) {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
            ctx.strokeStyle = "#9ca3af";
            ctx.setLineDash([4, 4]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // funciones nuevas de dibujo de contornos y flechas de flujo
        function drawContoursOnCanvas(contours) {
            // contours: [{level, segments:[ [ [x,y],[x,y],... ], ... ] }, ...]
            const palette = {
                80: "#ef4444",
                75: "#f59e0b",
                70: "#1e40af"
            };
            contours.forEach(c => {
                const stroke = palette[c.level] || "#111";
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 3]);
                c.segments.forEach(poly => {
                    ctx.beginPath();
                    ctx.moveTo(poly[0][0], poly[0][1]);
                    for (let i = 1; i < poly.length; i++) ctx.lineTo(poly[i][0], poly[i][1]);
                    ctx.stroke();
                });
                ctx.setLineDash([]);
                // Flechas de flujo (perpendicular) en algunos puntos de la primera poly
                c.segments.forEach(poly => drawFlowArrowsAlong(poly, c.level));
            });
        }

        function drawFlowArrowsAlong(poly, level) {
            if (!poly || poly.length < 2) return;
            const step = Math.max(2, Math.floor(poly.length / 6));
            for (let i = 0; i < poly.length - 1; i += step) {
                const p1 = { x: poly[i][0], y: poly[i][1] };
                const p2 = { x: poly[i+1][0], y: poly[i+1][1] };
                // tangent
                const tx = p2.x - p1.x;
                const ty = p2.y - p1.y;
                // normal (perpendicular)
                let nx = -ty;
                let ny = tx;
                // normalize
                const nlen = Math.sqrt(nx*nx + ny*ny) || 1;
                nx /= nlen; ny /= nlen;
                // direction of decrease: sample head on each side using IDW grid
                const sample1 = sampleHeadAt(p1.x + nx*6, p1.y + ny*6);
                const sample2 = sampleHeadAt(p1.x - nx*6, p1.y - ny*6);
                let dir = 1;
                if (sample1 !== null && sample2 !== null) dir = sample2 < sample1 ? -1 : 1;
                // arrow base and tip
                const base = { x: p1.x, y: p1.y };
                const tip = { x: p1.x + nx * 20 * dir, y: p1.y + ny * 20 * dir };
                drawArrow(base, tip, "#111");
            }
        }

        function drawArrow(from, to, color) {
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.8;
            ctx.stroke();
            // arrow head
            const angle = Math.atan2(to.y - from.y, to.x - from.x);
            const headlen = 6;
            ctx.beginPath();
            ctx.moveTo(to.x, to.y);
            ctx.lineTo(to.x - headlen * Math.cos(angle - Math.PI / 6), to.y - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(to.x - headlen * Math.cos(angle + Math.PI / 6), to.y - headlen * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(to.x, to.y);
            ctx.fillStyle = color;
            ctx.fill();
        }

        function drawLegend() {
            const startX = 12;
            let startY = 14;
            ctx.fillStyle = "rgba(255,255,255,0.85)";
            ctx.fillRect(startX - 6, startY - 10, 170, 80);
            ctx.strokeStyle = "#ddd"; ctx.strokeRect(startX - 6, startY - 10, 170, 80);
            ctx.font = "12px Arial";
            ctx.fillStyle = "#111";
            ctx.fillText("Leyenda:", startX + 10, startY + 4);
            const items = [
                { label: "Equipotencial 80 m", color: "#ef4444" },
                { label: "Equipotencial 75 m", color: "#f59e0b" },
                { label: "Equipotencial 70 m", color: "#1e40af" },
                { label: "Flecha = dirección de flujo", color: "#111" }
            ];
            let y = startY + 22;
            items.forEach(it => {
                ctx.fillStyle = it.color;
                ctx.fillRect(startX + 10, y - 8, 18, 6);
                ctx.fillStyle = "#111";
                ctx.fillText(it.label, startX + 36, y);
                y += 18;
            });
        }

        // Dibujo de puntos medios etc (igual que antes)
        function drawMidPoint(midPoint, avgElevation) {
            if (!midPoint) return;
            ctx.beginPath();
            ctx.arc(midPoint.x, midPoint.y, 6, 0, 2 * Math.PI);
            ctx.fillStyle = "#FF6B00";
            ctx.fill();
            ctx.strokeStyle = "#FFFFFF";
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.font = "bold 12px Arial";
            ctx.fillStyle = "#FF6B00";
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            const text = `${avgElevation.toFixed(1)}`;
            const textWidth = ctx.measureText(text).width;
            const padding = 6;
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
            ctx.fillRect(
                midPoint.x - textWidth/2 - padding,
                midPoint.y - 30 - padding,
                textWidth + padding * 2,
                20 + padding
            );
            ctx.strokeStyle = "#FF6B00";
            ctx.lineWidth = 1;
            ctx.strokeRect(
                midPoint.x - textWidth/2 - padding,
                midPoint.y - 30 - padding,
                textWidth + padding * 2,
                20 + padding
            );
            ctx.fillStyle = "#FF6B00";
            ctx.fillText(text, midPoint.x, midPoint.y - 20);
            ctx.beginPath();
            ctx.moveTo(midPoint.x, midPoint.y - 6);
            ctx.lineTo(midPoint.x, midPoint.y - 25);
            ctx.strokeStyle = "#FF6B00"; ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]); ctx.stroke(); ctx.setLineDash([]);
        }

        function drawAdditionalMidPoint(midPoint, avgElevation) {
            if (!midPoint) return;
            ctx.beginPath();
            ctx.arc(midPoint.x, midPoint.y, 6, 0, 2 * Math.PI);
            ctx.fillStyle = "#059669";
            ctx.fill();
            ctx.strokeStyle = "#FFFFFF";
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.font = "bold 12px Arial";
            ctx.fillStyle = "#059669";
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            const text = `${avgElevation.toFixed(1)}`;
            const textWidth = ctx.measureText(text).width;
            const padding = 6;
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
            ctx.fillRect(
                midPoint.x - textWidth/2 - padding,
                midPoint.y - 30 - padding,
                textWidth + padding * 2,
                20 + padding
            );
            ctx.strokeStyle = "#059669";
            ctx.lineWidth = 1;
            ctx.strokeRect(
                midPoint.x - textWidth/2 - padding,
                midPoint.y - 30 - padding,
                textWidth + padding * 2,
                20 + padding
            );
            ctx.fillStyle = "#059669";
            ctx.fillText(text, midPoint.x, midPoint.y - 20);
            ctx.beginPath();
            ctx.moveTo(midPoint.x, midPoint.y - 6);
            ctx.lineTo(midPoint.x, midPoint.y - 25);
            ctx.strokeStyle = "#059669"; ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]); ctx.stroke(); ctx.setLineDash([]);
        }

        function drawAdditionalLine(points) {
            if (!points || points.length < 2) return;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
            ctx.strokeStyle = "#8B5CF6";
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawAdditionalPoint(point, index) {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);
            ctx.fillStyle = "#8B5CF6";
            ctx.fill();
            ctx.strokeStyle = "#FFFFFF";
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.font = "bold 12px Arial";
            ctx.fillStyle = "#8B5CF6";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(String.fromCharCode(65 + index), point.x, point.y);
            ctx.font = "bold 11px Arial";
            ctx.textBaseline = "bottom";
            const text = `${point.elevation}m`;
            const textWidth = ctx.measureText(text).width;
            const padding = 4;
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
            ctx.fillRect(
                point.x - textWidth/2 - padding,
                point.y - 25 - padding,
                textWidth + padding * 2,
                14 + padding
            );
            ctx.strokeStyle = "#8B5CF6";
            ctx.lineWidth = 1;
            ctx.strokeRect(
                point.x - textWidth/2 - padding,
                point.y - 25 - padding,
                textWidth + padding * 2,
                14 + padding
            );
            ctx.fillStyle = "#8B5CF6";
            ctx.fillText(text, point.x, point.y - 20);
        }

        /* ---------------- GRID & IDW para calcular campo de head ---------------- */
        function buildControlPoints() {
            // Control points: pozos definidos + líneas seleccionadas (equipotential endpoints)
            const cps = [];
            // wells (approx center)
            const cxA = (WELL_A.x1 + WELL_A.x2) / 2;
            const cyA = (WELL_A.y1 + WELL_A.y2) / 2;
            cps.push({ x: cxA, y: cyA, h: WELL_A.head });

            const cxB = (WELL_B.x1 + WELL_B.x2) / 2;
            const cyB = (WELL_B.y1 + WELL_B.y2) / 2;
            cps.push({ x: cxB, y: cyB, h: WELL_B.head });

            // puntos adicionales seleccionados (si existen)
            additionalPoints.forEach(p => cps.push({ x: p.x, y: p.y, h: p.elevation }));
            // puntos de líneas equipotenciales guardadas
            lines.filter(l => l.type === "equipotential").forEach(l => {
                // usar los dos puntos iniciales (p1,p2) con elevaciones cercanas estimadas
                if (l.points && l.points.length >= 2) {
                    const p1 = l.points[0], p2 = l.points[1];
                    cps.push({ x: p1.x, y: p1.y, h: Math.round(calculateElevation(p1.y)) });
                    cps.push({ x: p2.x, y: p2.y, h: Math.round(calculateElevation(p2.y)) });
                }
            });

            // si RIVER_HEAD definido, sample river points
            if (RIVER_HEAD !== null) {
                RIVER_POINTS.forEach(pt => cps.push({ x: pt.x, y: pt.y, h: RIVER_HEAD }));
            }

            return cps;
        }

        function computeHeadGrid() {
            // produce a grid of heads computed by IDW from control points
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            const cps = buildControlPoints();
            if (!cps.length) return null;

            const cols = Math.ceil(w / GRID_STEP);
            const rows = Math.ceil(h / GRID_STEP);
            const grid = { cols, rows, step: GRID_STEP, w, h, values: [] };

            for (let j = 0; j <= rows; j++) {
                const row = [];
                for (let i = 0; i <= cols; i++) {
                    const gx = i * GRID_STEP;
                    const gy = j * GRID_STEP;
                    // IDW
                    let num = 0, den = 0;
                    for (const cp of cps) {
                        const dx = gx - cp.x;
                        const dy = gy - cp.y;
                        const d2 = dx*dx + dy*dy + EPS;
                        const wght = 1 / Math.pow(Math.sqrt(d2), IDW_POWER);
                        num += cp.h * wght;
                        den += wght;
                    }
                    const head = num / den;
                    row.push(head);
                }
                grid.values.push(row);
            }
            return grid;
        }

        /* ---------------- marching squares básico para extraer contornos ---------------- */
        function marchingSquares(grid, level) {
            // returns array of polylines (as arrays of [x,y] points)
            const segments = [];
            const cols = grid.cols, rows = grid.rows, step = grid.step;
            const vals = grid.values;

            // helper to interpolate between two grid nodes
            function interp(i1,j1,i2,j2) {
                const v1 = vals[j1][i1], v2 = vals[j2][i2];
                const t = (level - v1) / (v2 - v1 || EPS);
                const x = (i1 + t * (i2 - i1)) * step;
                const y = (j1 + t * (j2 - j1)) * step;
                return [x, y];
            }

            // marching squares over cells
            for (let j = 0; j < rows; j++) {
                for (let i = 0; i < cols; i++) {
                    const vTL = vals[j][i];
                    const vTR = vals[j][i+1];
                    const vBR = vals[j+1][i+1];
                    const vBL = vals[j+1][i];
                    let code = 0;
                    if (vTL >= level) code |= 1;
                    if (vTR >= level) code |= 2;
                    if (vBR >= level) code |= 4;
                    if (vBL >= level) code |= 8;
                    const segs = [];
                    // based on code, compute intersections (12 cases mirrored)
                    // We'll compute up to two segment endpoints per case
                    switch (code) {
                        case 0:
                        case 15:
                            break;
                        case 1:
                        case 14: {
                            const a = interp(i, j, i+1, j); // top
                            const b = interp(i, j, i, j+1); // left
                            segs.push([a,b]);
                            break;
                        }
                        case 2:
                        case 13: {
                            const a = interp(i, j, i+1, j); // top
                            const b = interp(i+1, j, i+1, j+1); // right
                            segs.push([a,b]);
                            break;
                        }
                        case 3:
                        case 12: {
                            const a = interp(i+1, j, i+1, j+1); // right
                            const b = interp(i, j, i, j+1); // left
                            segs.push([a,b]);
                            break;
                        }
                        case 4:
                        case 11: {
                            const a = interp(i+1, j, i+1, j+1); // right
                            const b = interp(i+1, j+1, i, j+1); // bottom
                            segs.push([a,b]);
                            break;
                        }
                        case 5: {
                            const a = interp(i, j, i+1, j);
                            const b = interp(i+1, j+1, i, j+1);
                            segs.push([a,b]);
                            break;
                        }
                        case 10: {
                            const a = interp(i+1, j, i+1, j+1);
                            const b = interp(i, j, i, j+1);
                            segs.push([a,b]);
                            break;
                        }
                        case 6:
                        case 9: {
                            const a = interp(i, j, i+1, j);
                            const b = interp(i+1, j+1, i, j+1);
                            segs.push([a,b]);
                            break;
                        }
                        case 7:
                        case 8: {
                            const a = interp(i, j, i, j+1);
                            const b = interp(i+1, j+1, i, j+1);
                            segs.push([a,b]);
                            break;
                        }
                        default:
                            break;
                    }
                    // collect segments
                    segs.forEach(s => segments.push(s));
                }
            }

            // Now connect segments into polylines (simple greedy connection)
            const polylines = [];
            const used = new Array(segments.length).fill(false);

            function dist2(a,b){ const dx=a[0]-b[0], dy=a[1]-b[1]; return dx*dx+dy*dy; }

            for (let s = 0; s < segments.length; s++) {
                if (used[s]) continue;
                used[s] = true;
                let poly = [segments[s][0], segments[s][1]];
                let extended = true;
                while (extended) {
                    extended = false;
                    for (let t = 0; t < segments.length; t++) {
                        if (used[t]) continue;
                        const seg = segments[t];
                        // try to attach at end
                        if (dist2(poly[poly.length-1], seg[0]) < 1.0) {
                            poly.push(seg[1]); used[t]=true; extended=true; break;
                        } else if (dist2(poly[poly.length-1], seg[1]) < 1.0) {
                            poly.push(seg[0]); used[t]=true; extended=true; break;
                        } else if (dist2(poly[0], seg[1]) < 1.0) {
                            poly.unshift(seg[0]); used[t]=true; extended=true; break;
                        } else if (dist2(poly[0], seg[0]) < 1.0) {
                            poly.unshift(seg[1]); used[t]=true; extended=true; break;
                        }
                    }
                }
                polylines.push(poly);
            }

            return polylines;
        }

        /* ---------------- generar contornos a partir de grid ---------------- */
        function generateContours() {
            const grid = computeHeadGrid();
            if (!grid) {
                alert("No hay puntos de control suficientes para generar contornos.");
                return;
            }
            const contours = [];
            for (const level of CONTOUR_LEVELS) {
                const segments = marchingSquares(grid, level);
                contours.push({ level, segments });
            }
            canvas.__contours = contours;
            drawAll();
            // mostrar resultados en panel
            showContoursInfo(contours);
        }

        function showContoursInfo(contours) {
            resultsBox.classList.remove("hidden");
            let html = `<b>Equipotenciales generadas:</b><br/>`;
            for (const c of contours) {
                html += `Nivel ${c.level} m: ${c.segments.length} polilíneas (aprox.)<br/>`;
            }
            html += `<hr/><b>Conceptos y fórmulas:</b><br/>
                     i = Δh / ΔL (gradiente hidráulico)<br/>
                     Q = -K · i · A (Ley de Darcy) — muestra aquí i y Q usando puntos seleccionados.<br/>
                     (Las equipotenciales unen puntos con misma elevación; las líneas de flujo son perpendiculares).`;
            resultsBox.innerHTML = html;
        }

        // sample head at pixel coordinates using nearest grid (recompute grid if needed)
        function sampleHeadAt(px, py) {
            const grid = canvas.__lastGrid || computeHeadGrid();
            if (!grid) return null;
            canvas.__lastGrid = grid;
            const step = grid.step;
            const i = Math.round(px / step);
            const j = Math.round(py / step);
            if (j < 0 || j >= grid.values.length) return null;
            if (i < 0 || i >= grid.values[0].length) return null;
            return grid.values[j][i];
        }

        /* ---------------- Botón Limpiar ---------------- */
        btnClear.addEventListener("click", () => {
            lines = [];
            selectedPoints = [];
            additionalPoints = [];
            resultsBox.classList.add("hidden");
            resultsBox.innerHTML = "";
            equipotentialCompleted = false;
            additionalPointsCompleted = false;
            canvas.__contours = null;
            canvas.__lastGrid = null;
            updateInstruction();
            drawAll();
        });

        /* ---------------- Botones herramienta ---------------- */
        btnEquipotential.addEventListener("click", () => {
            if (!equipotentialCompleted) {
                setTool("equipotential", btnEquipotential);
            } else {
                instructionText.textContent = "Ya has completado la línea equipotencial. Cambia a 'Puntos Adicionales' o presiona 'Limpiar' para empezar de nuevo.";
            }
        });

        btnAdditionalPoints.addEventListener("click", () => {
            if (!additionalPointsCompleted) {
                setTool("additionalPoints", btnAdditionalPoints);
            } else {
                instructionText.textContent = "Ya has completado la selección de puntos adicionales. Presiona 'Limpiar' para empezar de nuevo.";
            }
        });

        btnGenerateContours.addEventListener("click", () => {
            generateContours();
        });

        function setTool(newTool, activeButton) {
            tool = newTool;
            btnEquipotential.classList.remove("bg-slate-400", "text-white");
            btnAdditionalPoints.classList.remove("bg-purple-400", "text-white");
            if (activeButton) {
                if (newTool === "equipotential") {
                    activeButton.classList.add("bg-slate-400", "text-white");
                } else if (newTool === "additionalPoints") {
                    activeButton.classList.add("bg-purple-400", "text-white");
                }
            }
            if (modeMode === "coords") {
                coordElementType.value = newTool === "additionalPoints" ? "additional" : "equipotential";
            }
            updateInstruction();
        }

        function updateInstruction() {
            if (equipotentialCompleted && tool === "equipotential") {
                instructionText.textContent = "Línea equipotencial completada. Cambia a 'Puntos Adicionales' para agregar más puntos o genera contornos.";
            } else if (additionalPointsCompleted && tool === "additionalPoints") {
                instructionText.textContent = "Puntos adicionales completados. Presiona 'Limpiar' para empezar de nuevo.";
            } else if (tool === "equipotential") {
                instructionText.textContent = `Selecciona ${Math.max(0, 2 - selectedPoints.length)} punto(s) más para la línea equipotencial`;
            } else if (tool === "additionalPoints") {
                if (!equipotentialCompleted) {
                    instructionText.textContent = "Primero completa la línea equipotencial antes de agregar puntos adicionales.";
                } else {
                    instructionText.textContent = `Selecciona ${Math.max(0, 2 - additionalPoints.length)} punto(s) adicionales`;
                }
            }
        }

        btnModeManual.addEventListener("click", () => setMode("manual"));
        btnModeCoords.addEventListener("click", () => setMode("coords"));

        /* ---------------- Aplicar coordenadas desde el formulario ---------------- */
        btnApplyCoords.addEventListener("click", () => {
            const elementType = coordElementType.value;
            const x1 = in_x1.value ? Number(in_x1.value) : null;
            const y1 = in_y1.value ? Number(in_y1.value) : null;
            const z1 = in_z1.value ? Number(in_z1.value) : null;
            const x2 = in_x2.value ? Number(in_x2.value) : null;
            const y2 = in_y2.value ? Number(in_y2.value) : null;
            const z2 = in_z2.value ? Number(in_z2.value) : null;

            if ((x1 === null || x2 === null) && (z1 === null || z2 === null)) {
                alert("Por favor ingresa al menos las coordenadas X para ambos puntos o las elevaciones Z.");
                return;
            }

            let p1y = y1;
            if ((p1y === null || isNaN(p1y)) && z1 !== null && canvas.__elevToY) p1y = canvas.__elevToY(z1);
            let p2y = y2;
            if ((p2y === null || isNaN(p2y)) && z2 !== null && canvas.__elevToY) p2y = canvas.__elevToY(z2);

            if ((p1y === null || p2y === null) || (x1 === null || x2 === null)) {
                alert("Necesitamos valores X y Y (o X + Z para calcular Y).");
                return;
            }

            const adjustedX1 = x1 - ORIGIN_X;
            const adjustedX2 = x2 - ORIGIN_X;

            const p1 = { x: x1, y: p1y, adjustedX: adjustedX1, elevation: calculateElevation(p1y) };
            const p2 = { x: x2, y: p2y, adjustedX: adjustedX2, elevation: calculateElevation(p2y) };

            const minX = 1;
            const maxX = 464;
            if (adjustedX1 < minX || adjustedX1 > maxX || adjustedX2 < minX || adjustedX2 > maxX) {
                alert(`Las coordenadas X ajustadas deben estar entre ${minX} y ${maxX}`);
                return;
            }

            if (elementType === "equipotential") {
                const elev1 = (z1 !== null && !isNaN(z1)) ? Math.round(z1) : calculateElevation(p1.y);
                const elev2 = (z2 !== null && !isNaN(z2)) ? Math.round(z2) : calculateElevation(p2.y);
                let extendedPoint = calculateExtendedPoint(p1, p2);

                const equipotentialLine = { type: "equipotential", points: [p1, p2, extendedPoint] };

                const midPoint = {
                    x: (p1.x + p2.x) / 2,
                    y: (p1.y + p2.y) / 2
                };
                const avgElevation = (elev1 + elev2) / 2;

                equipotentialLine.midPoint = midPoint;
                equipotentialLine.avgElevation = avgElevation;

                lines = lines.filter(l => l.type === "equipotential");
                lines.push(equipotentialLine);

                calculateHydraulicData(p1, p2, elev1, elev2, midPoint, avgElevation);

                equipotentialCompleted = true;
                coordForm.classList.add("hidden");
                instructionText.textContent = "Línea equipotencial completada (modo Coordenadas). Ahora puedes generar contornos o seleccionar puntos adicionales.";
            } else if (elementType === "additional") {
                if (!equipotentialCompleted) {
                    alert("Primero debes completar la línea equipotencial antes de agregar puntos adicionales.");
                    return;
                }
                if (additionalPointsCompleted) {
                    alert("Ya se han completado los puntos adicionales. Limpia para empezar de nuevo.");
                    return;
                }

                additionalPoints.push(p1, p2);
                const additionalLine = {
                    type: "additional",
                    points: [p1, p2]
                };
                const midPoint = {
                    x: (p1.x + p2.x) / 2,
                    y: (p1.y + p2.y) / 2
                };
                const avgElevation = (p1.elevation + p2.elevation) / 2;
                additionalLine.midPoint = midPoint;
                additionalLine.avgElevation = avgElevation;
                lines.push(additionalLine);
                additionalPointsCompleted = true;
                showAdditionalPointsInfo();
                instructionText.textContent = "Puntos adicionales completados (modo Coordenadas). Presiona 'Limpiar' para empezar de nuevo.";
            }

            drawAll();
        });

        /* ---------------- Inicialización ---------------- */
        setTool("equipotential", btnEquipotential);
        setMode("manual");
        loadImageSafely();

        window.__exercise6 = {
            canvas,
            lines,
            selectedPoints,
            additionalPoints,
            redraw: drawAll,
            detectAxisAndDraw,
            generateContours
        };
    </script>
</body>
</html>
