<section
  class="flex flex-col items-center justify-center p-6 border border-[var(--borderEjercicio)] 
  bg-[var(--cardEjercicio)] shadow-[var(--shadowEjercicio)] rounded-xl transition-colors duration-300"
>
  <h3 class="text-lg font-semibold text-[var(--titles)] mb-4 text-center">
    Ejercicio 6 – Flujo en un acuífero libre
  </h3>

  <div class="flex flex-wrap justify-center gap-3 mb-4">
    <button id="btnWater"
      class="px-4 py-2 rounded-lg font-medium bg-slate-200 text-slate-800 border border-slate-300 
             hover:bg-slate-300 hover:text-slate-900 shadow-sm transition-all duration-200">
      Línea freática
    </button>

    <button id="btnEquip"
      class="px-4 py-2 rounded-lg font-medium bg-gray-100 text-gray-700 border border-gray-300 
             hover:bg-gray-200 hover:text-gray-900 shadow-sm transition-all duration-200">
      Equipotencial (70–80 m)
    </button>

    <button id="btnFlow"
      class="px-4 py-2 rounded-lg font-medium bg-stone-200 text-stone-800 border border-stone-300 
             hover:bg-stone-300 hover:text-stone-900 shadow-sm transition-all duration-200">
      Línea de flujo
    </button>

    <button id="btnClear"
      class="px-4 py-2 rounded-lg font-medium bg-neutral-100 text-neutral-600 border border-neutral-300 
             hover:bg-neutral-200 hover:text-neutral-800 shadow-sm transition-all duration-200">
      Limpiar
    </button>
  </div>

  <div class="relative flex flex-col items-center" style="width:100%;">
    <canvas
      id="acuiferoCanvas"
      class="border border-gray-300 rounded-lg shadow-md cursor-crosshair bg-white"
      style="max-width:700px; width:100%; height:auto; display:block;"
    ></canvas>

    <div id="coordBox"
         style="position:absolute; pointer-events:none; background:rgba(255,255,255,0.9); border:1px solid rgba(0,0,0,0.12);
                padding:6px 8px; border-radius:6px; font-size:12px; color:#111; display:none; transform:translate(8px,8px);">
      x: 0, y: 0 <br/> elev: 0
    </div>

    <p id="loadingText" class="text-gray-500 italic mt-2">Cargando imagen...</p>
    <p id="instructionText" class="text-sm text-gray-600 mt-2">Selecciona 2 puntos para crear la línea freática</p>
  </div>

  <div id="resultsBox" class="hidden mt-4 p-3 rounded-lg bg-slate-50 text-sm text-gray-800 border border-slate-200 max-w-md text-center"></div>

  <p class="mt-5 text-sm text-[var(--textoCardCanvas)] text-center leading-relaxed max-w-md">
    Selecciona 2 puntos para crear la <b>línea freática</b>, las <b>líneas equipotenciales (70 m, 75 m, 80 m)</b> 
    y las <b>líneas de flujo</b> sobre el esquema del acuífero libre.
  </p>
</section>

<script is:client>
/* eslint-disable no-console */
const canvas = document.getElementById("acuiferoCanvas");
const ctx = canvas.getContext("2d");
const loadingText = document.getElementById("loadingText");
const instructionText = document.getElementById("instructionText");
const resultsBox = document.getElementById("resultsBox");
const coordBox = document.getElementById("coordBox");

const btnWater = document.getElementById("btnWater");
const btnEquip = document.getElementById("btnEquip");
const btnFlow = document.getElementById("btnFlow");
const btnClear = document.getElementById("btnClear");

let tool = "waterTable";
let selectedPoints = [];
let lines = [];
let baseImg = new Image();
let baseLoaded = false;
let waterTableCompleted = false; // Nueva variable para controlar estado

// pozos (coordenadas internas, mantenidas como antes)
const WELL_A = { x: 20, y: 260, head: 80 };
const WELL_B = { x: 480, y: 280, head: 70 };

// parámetros visuales/limite del río calculado dinámicamente (se ajusta después de cargar la imagen)
let RIVER_X = null;        // x (en pixels del canvas) donde consideramos que está el río
const RIGHT_MARGIN = 20;   // margen para no dibujar sobre el borde

// CARGA IMAGEN con fallbacks (igual que antes)
async function loadImageSafely() {
  const sources = [
    "/src/assets/image33-1.png",
    "https://books.gw-project.org/conceptual-and-visual-understanding-of-hydraulic-head-and-groundwater-flow/wp-content/uploads/sites/14/2020/12/image33-1.png",
    "https://corsproxy.io/?" + encodeURIComponent("https://books.gw-project.org/conceptual-and-visual-understanding-of-hydraulic-head-and-groundwater-flow/wp-content/uploads/sites/14/2020/12/image33-1.png")
  ];

  for (const src of sources) {
    try {
      await new Promise((resolve, reject) => {
        baseImg = new Image();
        baseImg.crossOrigin = "anonymous";
        baseImg.src = src;
        baseImg.onload = () => resolve();
        baseImg.onerror = reject;
      });

      baseLoaded = true;
      loadingText.style.display = "none";

      // ajustar canvas tamaño natural de la imagen
      canvas.width = baseImg.naturalWidth || baseImg.width;
      canvas.height = baseImg.naturalHeight || baseImg.height;

      // detectar posiciones importantes (eje vertical y aproximación río)
      await detectAxisAndDraw();
      return;
    } catch (err) {
      console.warn("Falló cargar:", src, err);
    }
  }

  loadingText.textContent = "Error al cargar la imagen base.";
  // fallback: establecer tamaño razonable
  canvas.width = 700;
  canvas.height = 400;
  detectAxisAndDraw(); // dibuja fallback
}

// Detecta top/bottom del eje vertical y aproxima la posición del río (centro-derecha)
async function detectAxisAndDraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // dibuja la imagen si está
  if (baseLoaded) ctx.drawImage(baseImg, 0, 0, canvas.width, canvas.height);

  // Inicial fallback para axis
  let axisTop = Math.round(canvas.height * 0.11);
  let axisBottom = Math.round(canvas.height * 0.975);

  // Intenta leer imageData para detectar eje vertical/river region (si CORS lo permite)
  try {
    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imgData.data;
    const w = canvas.width, h = canvas.height;

    // buscar columna con muchos pixeles oscuros (posible eje/labels)
    const colCounts = new Uint32Array(w);
    for (let x = 0; x < w; x++) {
      let cnt = 0;
      for (let y = 0; y < h; y++) {
        const idx = (y * w + x) * 4;
        const r = data[idx], g = data[idx+1], b = data[idx+2];
        if (r + g + b < 200) cnt++;
      }
      colCounts[x] = cnt;
    }
    let axisCol = 0, maxc = 0;
    for (let x = 0; x < w; x++) {
      if (colCounts[x] > maxc) { maxc = colCounts[x]; axisCol = x; }
    }

    // buscar filas oscuras en ventana pequeña alrededor del axisCol
    const windowHalf = Math.min(6, Math.floor(w / 150));
    const left = Math.max(0, axisCol - windowHalf);
    const right = Math.min(w - 1, axisCol + windowHalf);

    const rowsWithDark = [];
    for (let y = 0; y < h; y++) {
      let rowDark = 0;
      for (let x = left; x <= right; x++) {
        const idx = (y * w + x) * 4;
        if (data[idx] + data[idx+1] + data[idx+2] < 200) rowDark++;
      }
      if (rowDark > 0) rowsWithDark.push(y);
    }
    if (rowsWithDark.length > 5) {
      axisTop = rowsWithDark[0];
      axisBottom = rowsWithDark[rowsWithDark.length - 1];
    }

    // aproximación de la posición horizontal del río: buscar banda azul (simple)
    // buscamos la columna con mayor suma de azul en la mitad derecha de la imagen
    let blueSumCols = new Float32Array(w);
    for (let x = Math.floor(w*0.25); x < w; x++) {
      let bs = 0;
      for (let y = Math.floor(h*0.5); y < Math.floor(h*0.95); y++) {
        const idx = (y * w + x) * 4;
        const r = data[idx], g = data[idx+1], b = data[idx+2];
        // ponderamos azul - rojo/verde
        bs += Math.max(0, b - (r + g) * 0.5);
      }
      blueSumCols[x] = bs;
    }
    // encontrar columna con max azulSum
    let blueMax = 0, blueCol = Math.round(w * 0.55);
    for (let x = Math.floor(w*0.25); x < w; x++) {
      if (blueSumCols[x] > blueMax) { blueMax = blueSumCols[x]; blueCol = x; }
    }
    // river x será blueCol (si detectado), sino centro-derecha
    RIVER_X = blueMax > 0 ? blueCol : Math.round(canvas.width * 0.55);

  } catch (err) {
    // si no se pudo leer imageData por CORS, fallback valores
    RIVER_X = Math.round(canvas.width * 0.55);
    console.warn("No se pudo acceder a imageData (CORS?), usando fallback.", err);
  }

  // asignar axis funcs (útil si quieres mapear elevaciones)
  canvas.__axisTop = axisTop;
  canvas.__axisBottom = axisBottom;
  canvas.__elevToY = (elev) => {
    const maxE = 100, minE = 0;
    const t = (maxE - elev) / (maxE - minE);
    return axisTop + t * (axisBottom - axisTop);
  };

  drawAll();
}

// convierte coordenadas del evento a coordenadas de imagen (escaladas)
function clientToImageCoords(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  let x = (clientX - rect.left) * scaleX;
  let y = (clientY - rect.top) * scaleY;
  // adjustedX como antes (resta de 100 en tu diseño)
  const adjustedX = x >= 100 ? x - 100 : x;
  return { x, y, adjustedX, rect, isValid: x >= 100 };
}

// tooltip coordenadas - mantener visible y funcionando
canvas.addEventListener("mousemove", (e) => {
  if (!baseLoaded) return;
  const { x, y, adjustedX, rect, isValid } = clientToImageCoords(e.clientX, e.clientY);
  if (!isValid) { coordBox.style.display = "none"; return; }

  let elev = null;
  if (canvas.__elevToY) {
    const top = canvas.__axisTop, bottom = canvas.__axisBottom;
    const t = (y - top) / (bottom - top);
    const computedElev = Math.round((1 - t) * 100);
    elev = Math.max(0, Math.min(100, computedElev));
  }

  coordBox.style.display = "block";
  // colocarlo relativo al canvas DOM (para evitar que salga fuera)
  const domLeft = (e.clientX - rect.left);
  const domTop = (e.clientY - rect.top);
  coordBox.style.left = domLeft + "px";
  coordBox.style.top = domTop + "px";
  coordBox.innerHTML = `x: ${Math.round(adjustedX)}, y: ${Math.round(y)}<br/>elev: ${elev !== null ? elev : '-'}`;
});

canvas.addEventListener("mouseout", () => { coordBox.style.display = "none"; });

// CLICK - selección de puntos (ahora 2 puntos para waterTable)
canvas.addEventListener("click", (e) => {
  if (!baseLoaded) return;
  
  // Validación: si ya se completó la línea freática, no permitir más selecciones
  if (waterTableCompleted && tool === "waterTable") {
    instructionText.textContent = "Ya has completado la línea freática. Presiona 'Limpiar' para empezar de nuevo.";
    return;
  }

  const { x, y, adjustedX, isValid } = clientToImageCoords(e.clientX, e.clientY);
  if (!isValid) {
    instructionText.textContent = "Selecciona dentro del área válida (x ≥ 100)";
    return;
  }

  // validación extra: punto dentro de rango horizontal entre pozos (ajustado)
  const adj = adjustedX;
  const minX = WELL_A.x - 20;
  const maxX = WELL_B.x + 20;
  if (adj < minX || adj > maxX) {
    instructionText.textContent = "Selecciona dentro del rango entre los pozos.";
    return;
  }

  const point = { x, y, adjustedX: adj };
  selectedPoints.push(point);

  if (tool === "waterTable" && selectedPoints.length === 2) {
    // Calcular elevaciones de los puntos seleccionados (como enteros)
    const elevation1 = calculateElevation(selectedPoints[0].y);
    const elevation2 = calculateElevation(selectedPoints[1].y);
    
    // Extender la línea desde segundo punto hacia el río, pero sin sobrepasarlo
    const [p1, p2] = selectedPoints;
    // calcular recta (slope) y extender hasta RIVER_X - margin
    const slope = (p2.y - p1.y) / (p2.x - p1.x);
    // queremos que la línea llegue AL RÍO, pero no lo sobrepase
    const marginBeforeRiver = 8; // px antes del río para que no lo sobrepase visualmente
    const extendedX = Math.min(RIVER_X - marginBeforeRiver, canvas.width - RIGHT_MARGIN);
    // si p2.x already beyond extendedX (rare), usar extendedX = p2.x
    const targetX = Math.max(p2.x, extendedX);
    const extendedY = p2.y + slope * (targetX - p2.x);

    // push line with 3 points: p1 -> p2 -> extended point (this keeps a straight extension)
    const extendedPoint = { x: targetX, y: extendedY };
    lines.push({ type: "waterTable", points: [p1, p2, extendedPoint] });

    // calcular datos hidráulicos dinámicos basados en las elevaciones de p1,p2
    calculateHydraulicData(p1, p2, elevation1, elevation2);

    // limpiar selección para siguiente trazado y marcar como completado
    selectedPoints = [];
    waterTableCompleted = true;
    instructionText.textContent = "Línea freática completada. Presiona 'Limpiar' para empezar de nuevo.";
  } else if (tool !== "waterTable" && selectedPoints.length === 3) {
    lines.push({ type: tool, points: [...selectedPoints] });
    selectedPoints = [];
  }

  updateInstruction();
  drawAll();
});

// Función para calcular elevación basada en posición Y (como entero)
function calculateElevation(y) {
  if (!canvas.__axisTop || !canvas.__axisBottom) return null;
  
  const top = canvas.__axisTop;
  const bottom = canvas.__axisBottom;
  const t = (y - top) / (bottom - top);
  const computedElev = (1 - t) * 100;
  // Redondear al entero más cercano
  return Math.round(Math.max(0, Math.min(100, computedElev)));
}

// botones
btnClear.addEventListener("click", () => {
  lines = [];
  selectedPoints = [];
  resultsBox.classList.add("hidden");
  waterTableCompleted = false; // Resetear el estado de completado
  updateInstruction();
  drawAll();
});

btnWater.addEventListener("click", () => {
  if (!waterTableCompleted) {
    setTool("waterTable", btnWater);
  } else {
    instructionText.textContent = "Ya has completado la línea freática. Presiona 'Limpiar' para empezar de nuevo.";
  }
});

btnEquip.addEventListener("click", () => setTool("equipotential", btnEquip));
btnFlow.addEventListener("click", () => setTool("flowLine", btnFlow));

function setTool(newTool, activeButton) {
  tool = newTool;
  [btnWater, btnEquip, btnFlow].forEach((b) => {
    if (!b) return;
    b.classList.remove("bg-slate-400", "bg-gray-300", "bg-stone-300", "text-white");
  });
  if (activeButton) activeButton.classList.add("bg-slate-400", "text-white");
  updateInstruction();
}

function updateInstruction() {
  if (waterTableCompleted && tool === "waterTable") {
    instructionText.textContent = "Línea freática completada. Presiona 'Limpiar' para empezar de nuevo.";
  } else if (tool === "waterTable") {
    instructionText.textContent = `Selecciona ${Math.max(0, 2 - selectedPoints.length)} punto(s) más para la línea freática`;
  } else {
    instructionText.textContent = `Selecciona ${Math.max(0, 3 - selectedPoints.length)} punto(s) más`;
  }
}

/* ---------------- DIBUJO ---------------- */
function drawAll() {
  if (!ctx) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (baseLoaded) ctx.drawImage(baseImg, 0, 0, canvas.width, canvas.height);
  else {
    // fallback simple background if image failed
    ctx.fillStyle = "#f8fafc";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  // dibujar líneas guardadas
  for (const l of lines) drawLine(l.points, l.type);

  // puntos actualmente seleccionados (temporales)
  for (let i = 0; i < selectedPoints.length; i++) drawPoint(selectedPoints[i], i);

  // linea temporal entre puntos seleccionados
  if (selectedPoints.length > 1) drawTempLine(selectedPoints);
}

function drawLine(points, type) {
  if (!points || points.length < 2) return;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
  ctx.strokeStyle =
    type === "waterTable" ? "#1E90FF" :
    type === "equipotential" ? "#FFD700" : "#00C853";
  ctx.lineWidth = 2.5;
  ctx.stroke();
}

function drawPoint(p, i) {
  ctx.beginPath();
  ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
  ctx.fillStyle = "#dc2626";
  ctx.fill();
  ctx.font = "12px Arial";
  ctx.fillStyle = "#000";
  ctx.fillText(i + 1, p.x + 8, p.y - 8);
}

function drawTempLine(points) {
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
  ctx.strokeStyle = "#9ca3af";
  ctx.setLineDash([4, 4]);
  ctx.stroke();
  ctx.setLineDash([]);
}

function drawWell(well, label) {
  const drawX = well.x + 100; // tu offset de 100px como antes
  ctx.fillStyle = "#555";
  ctx.fillRect(drawX - 3, well.y - 60, 6, 60);
  ctx.fillStyle = "#0077b6";
  ctx.fillRect(drawX - 3, well.y - 10, 6, 10);
  ctx.font = "14px Arial";
  ctx.fillStyle = "#000";
  ctx.fillText(`${label} (${well.head} m)`, drawX - 20, well.y - 70);
}

/* ---------------- CÁLCULOS (basados en elevaciones reales de los puntos seleccionados) ---------------- */
function calculateHydraulicData(p1, p2, elev1, elev2) {
  // Usamos las elevaciones reales de los puntos seleccionados (enteros)
  const deltaH = Math.abs(elev1 - elev2); // diferencia de elevación en metros

  // dx en pixeles, dy en pixeles
  const dx_pix = p2.x - p1.x;
  const dy_pix = p1.y - p2.y; // diferencia vertical en pixeles (note: screen y increases downward)
  const dist_pix = Math.sqrt(dx_pix * dx_pix + dy_pix * dy_pix);

  // Escalas: aquí convertimos pix -> m.
  const metersPerPixel = 0.1; // EJEMPLO: 0.1 m por pixel (ajusta según tu escala real)
  const L_m = dist_pix * metersPerPixel; // distancia real aproximada en metros

  // gradiente i = deltaH / L
  const i = L_m > 0 ? deltaH / L_m : 0;

  // parámetros por defecto
  const K = 1e-4; // m/s
  const A = 40; // m^2

  const Q = K * i * A; // m^3/s

  // Mostrar resultados (dinámicos) - elevaciones como enteros
  resultsBox.classList.remove("hidden");
  resultsBox.innerHTML = `
    <b>Resultados (basados en los puntos seleccionados):</b><br/>
    Elevación punto 1: ${elev1} m<br/>
    Elevación punto 2: ${elev2} m<br/>
    Δh (diferencia de elevación): ${deltaH} m<br/>
    Distancia entre puntos: ${dist_pix.toFixed(0)} px ≈ ${L_m.toFixed(1)} m<br/>
    Gradiente hidráulico (i): ${i.toExponential(3)} m/m<br/>
    Conductividad hidráulica (K): ${K.toExponential(2)} m/s<br/>
    Caudal estimado (Q): ${Q.toExponential(3)} m³/s<br/>
    Dirección del flujo: ${elev1 > elev2 ? "del punto 1 → punto 2" : "del punto 2 → punto 1"}
  `;
}

/* ---------------- Inicialización ---------------- */
setTool("waterTable", btnWater);
loadImageSafely();

// Exponer helpers para debug si quieres
window.__exercise6 = {
  canvas,
  lines,
  selectedPoints,
  redraw: drawAll,
  detectAxisAndDraw
};
</script>